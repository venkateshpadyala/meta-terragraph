"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8245],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,u=c["".concat(s,".").concat(h)]||c[h]||m[h]||r;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1048:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={},o="Topology Management",l={unversionedId:"developer/Topology_Management",id:"developer/Topology_Management",title:"Topology Management",description:"This document describes the management of the network topology.",source:"@site/../docs/developer/Topology_Management.md",sourceDirName:"developer",slug:"/developer/Topology_Management",permalink:"/docs/developer/Topology_Management",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Topology_Management.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"Firmware Stats",permalink:"/docs/developer/Firmware_Stats"},next:{title:"Network Ignition",permalink:"/docs/developer/Network_Ignition"}},s={},d=[{value:"Network Elements",id:"network-elements",level:2},{value:"Topology Structure",id:"topology-structure",level:2},{value:"Topology Changes",id:"topology-changes",level:2},{value:"Parameter Assignment and Validation",id:"parameter-assignment-and-validation",level:2},{value:"Polarity",id:"polarity",level:3},{value:"Background",id:"background",level:4},{value:"Validation",id:"validation",level:4},{value:"Assignment",id:"assignment",level:4},{value:"Network-Wide Reassignment",id:"network-wide-reassignment",level:4},{value:"Golay Index",id:"golay-index",level:3},{value:"Background",id:"background-1",level:4},{value:"Validation",id:"validation-1",level:4},{value:"Assignment",id:"assignment-1",level:4},{value:"Network-Wide Reassignment",id:"network-wide-reassignment-1",level:4},{value:"Channel",id:"channel",level:3},{value:"Background",id:"background-2",level:4},{value:"Validation",id:"validation-2",level:4},{value:"Assignment",id:"assignment-2",level:4},{value:"Network-Wide Reassignment",id:"network-wide-reassignment-2",level:4},{value:"Control Superframe",id:"control-superframe",level:3},{value:"Background",id:"background-3",level:4},{value:"Validation",id:"validation-3",level:4},{value:"Assignment",id:"assignment-3",level:4},{value:"Network-Wide Reassignment",id:"network-wide-reassignment-3",level:4},{value:"Airtime",id:"airtime",level:3},{value:"Background",id:"background-4",level:4},{value:"Allocation",id:"allocation",level:4},{value:"Algorithms for Channel and Golay Assignment",id:"algorithms-for-channel-and-golay-assignment",level:3},{value:"Assignment for New Links",id:"assignment-for-new-links",level:4},{value:"Network-Wide Reassignment",id:"network-wide-reassignment-4",level:4},{value:"Identify all link groups",id:"identify-all-link-groups",level:5},{value:"Estimate group interference matrix",id:"estimate-group-interference-matrix",level:5},{value:"Build the group interference graph",id:"build-the-group-interference-graph",level:5},{value:"Allocate Golay codes or channels",id:"allocate-golay-codes-or-channels",level:5},{value:"Network State",id:"network-state",level:2},{value:"Node Status",id:"node-status",level:3},{value:"Link Status",id:"link-status",level:3},{value:"GPS Time Synchronization",id:"gps-time-synchronization",level:3},{value:"Minion Procedure",id:"minion-procedure",level:4},{value:"Controller Procedure",id:"controller-procedure",level:4},{value:"References",id:"references",level:2}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"topology-management"},"Topology Management"),(0,i.kt)("p",null,"This document describes the management of the network topology."),(0,i.kt)("h2",{id:"network-elements"},"Network Elements"),(0,i.kt)("p",null,"This section briefly describes the elements of a Terragraph network topology in\nthe context of the E2E service."),(0,i.kt)("p",null,"The three basic topology elements are listed below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Node")," - A general purpose compute unit that controls one or more sectors\n(wireless baseband cards)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Site")," - A collection of one or more nodes installed at the same physical\nlocation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Link")," - A connection between two sectors or nodes.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Nodes")," have several distinct properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DN/CN")," - Each node is either a ",(0,i.kt)("em",{parentName:"li"},"Distribution Node (DN)")," or ",(0,i.kt)("em",{parentName:"li"},"Client Node\n(CN)"),". DNs form the backbone of the Terragraph mesh network, while CNs act as\nthe termination point where service delivery takes place."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"POP")," - Any primary DN which is interconnected via fiber to a carrier's\nnetwork is known as a ",(0,i.kt)("em",{parentName:"li"},"Fiber Point-of-Presence (POP)"),". These POP nodes serve\nas the demarcation between the Terragraph network and the provider's backbone\nnetwork."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sectors"),' - Nodes control one or more sectors, which are identified by their\nMAC addresses (also referred to as "radio MACs" or "WLAN MACs"). Puma hardware\nsupports up to 4 sectors.')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Links")," have the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Wired/Wireless")," - Each link is either ",(0,i.kt)("em",{parentName:"li"},"wired")," (Ethernet) or ",(0,i.kt)("em",{parentName:"li"},"wireless"),"\n(RF). Wired links are used mainly between primary and secondary DNs."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Primary/Backup")," ",(0,i.kt)("em",{parentName:"li"},"(DN-to-CN links only)")," - CNs can only form one link, but\nadditional ",(0,i.kt)("em",{parentName:"li"},"backup links")," can be provided for use when the ",(0,i.kt)("em",{parentName:"li"},"primary link")," is\nunavailable.")),(0,i.kt)("h2",{id:"topology-structure"},"Topology Structure"),(0,i.kt)("p",null,"All topology structures are defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"Topology.thrift"),", and are contained\nwithin the parent structure ",(0,i.kt)("inlineCode",{parentName:"p"},"thrift::Topology"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Topology {\n  1: string name;\n  2: list<Node> nodes;\n  3: list<Link> links;\n  4: list<Site> sites;\n  5: Config config;\n}\n")),(0,i.kt)("p",null,"Currently, the properties captured by the ",(0,i.kt)("inlineCode",{parentName:"p"},"thrift::Topology")," structure can be\ncategorized as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Category"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Network Graph"),(0,i.kt)("td",{parentName:"tr",align:null},"Nodes, links, sites")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Controller Configuration"),(0,i.kt)("td",{parentName:"tr",align:null},"Deterministic Prefix Allocation config")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Network State"),(0,i.kt)("td",{parentName:"tr",align:null},"Node status, link liveness, link-up counters")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Installation/Inventory/Assets"),(0,i.kt)("td",{parentName:"tr",align:null},"Antenna azimuth, elevation")))),(0,i.kt)("p",null,"Most of these properties are persistent. However, the network state properties\nare non-persistent and get updated dynamically by the controller."),(0,i.kt)("p",null,"The full topology is stored only on the controller and is not propagated to\nnodes, with the exception of node configuration. In particular, the controller\nadds some topology information to the node's ",(0,i.kt)("inlineCode",{parentName:"p"},"topologyInfo")," configuration\nstructure, which includes the node's \"name\" and neighboring nodes' properties,\namong other details."),(0,i.kt)("p",null,'Lastly, a node\'s MAC address (or "node ID") is currently overloaded in several\nways:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"ZMQ Identity")," - Nodes use their MAC address as their ZMQ socket identity.\nRefer to ",(0,i.kt)("a",{parentName:"li",href:"/docs/developer/Communication_Protocol"},"Communication Protocol")," for\nfurther details."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Routing")," - The Open/R identity of each node is its MAC address. Refer to\n",(0,i.kt)("a",{parentName:"li",href:"/docs/developer/Routing_Layer"},"Routing Layer")," for further details."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Radio MAC")," - The node MAC is usually not equivalent to the radio MAC(s),\nparticularly on hardware providing multiple sectors.")),(0,i.kt)("h2",{id:"topology-changes"},"Topology Changes"),(0,i.kt)("p",null,"The network topology is provided to the controller as a file during startup, and\ncan be modified during runtime through ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp"),". All requested topology\nchanges are validated, and the controller will automatically assign any\nadditional parameters to a new node or link as necessary (discussed later). Most\nof the logic for topology changes resides in ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyWrapper"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp")," accepts the following ",(0,i.kt)("em",{parentName:"p"},"user operations")," on the topology:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"User Operation"),(0,i.kt)("th",{parentName:"tr",align:null},"Commands"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Modify Network Graph"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ADD_NODE"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"DEL_NODE"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"EDIT_NODE")," ",(0,i.kt)("br",null)," ",(0,i.kt)("inlineCode",{parentName:"td"},"ADD_LINK"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"DEL_LINK")," ",(0,i.kt)("br",null)," ",(0,i.kt)("inlineCode",{parentName:"td"},"ADD_SITE"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"DEL_SITE"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"EDIT_SITE")," ",(0,i.kt)("br",null)," ",(0,i.kt)("inlineCode",{parentName:"td"},"BULK_ADD"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Set MAC Address"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SET_NODE_MAC"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"SET_NODE_MAC_LIST"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"ADD_NODE_WLAN_MACS"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"DEL_NODE_WLAN_MACS"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"CHANGE_NODE_WLAN_MAC"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Set Network Parameters"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SET_NETWORK_PARAMS_REQ"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Set Topology Name"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SET_TOPOLOGY_NAME"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Reset Link-Up Counters"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RESET_TOPOLOGY_STATE"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Reallocate Node Prefixes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ALLOCATE_PREFIXES"))))),(0,i.kt)("p",null,"The topology is also modified upon receiving the following commands from other\napps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SET_NODE_STATUS")," - When a previously offline node sends a status report,\n",(0,i.kt)("inlineCode",{parentName:"li"},"StatusApp")," requests that ",(0,i.kt)("inlineCode",{parentName:"li"},"TopologyApp"),' mark the node as "online".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SET_NODE_PARAMS_REQ")," - When a previously offline node sends a status report,\n",(0,i.kt)("inlineCode",{parentName:"li"},"StatusApp")," requests that ",(0,i.kt)("inlineCode",{parentName:"li"},"TopologyApp")," send configuration to the node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BUMP_LINKUP_ATTEMPTS")," - When attempting to ignite a link, ",(0,i.kt)("inlineCode",{parentName:"li"},"IgnitionApp"),"\nrequests that ",(0,i.kt)("inlineCode",{parentName:"li"},"TopologyApp")," increment the corresponding link-up counter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LINK_STATUS")," - When a link's state changes, the ",(0,i.kt)("em",{parentName:"li"},"minion's")," ",(0,i.kt)("inlineCode",{parentName:"li"},"IgnitionApp"),"\nrequests that ",(0,i.kt)("inlineCode",{parentName:"li"},"TopologyApp")," update the corresponding link's liveness state.")),(0,i.kt)("h2",{id:"parameter-assignment-and-validation"},"Parameter Assignment and Validation"),(0,i.kt)("p",null,"On startup and before any topology change, the controller performs thorough\nvalidation of all relevant topology parameters. Additionally, when new elements\nare added, the controller automatically assigns node and link parameters. These\nprocesses are summarized in the following table, with additional details in the\nsections below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Element"),(0,i.kt)("th",{parentName:"tr",align:null},"Dynamic Changes?"),(0,i.kt)("th",{parentName:"tr",align:null},"Automatic?"),(0,i.kt)("th",{parentName:"tr",align:null},"Key(s)"),(0,i.kt)("th",{parentName:"tr",align:null},"Values"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Polarity"),(0,i.kt)("td",{parentName:"tr",align:null},"radio"),(0,i.kt)("td",{parentName:"tr",align:null},"yes (synchronized)"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"radioParamsOverrides.[radioMac].fwParams.polarity")),(0,i.kt)("td",{parentName:"tr",align:null},"1 (odd), 2 (even), 3 (hybrid-odd), 4 (hybrid-even)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Channel"),(0,i.kt)("td",{parentName:"tr",align:null},"radio"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"radioParamsOverrides.[radioMac].fwParams.channel")),(0,i.kt)("td",{parentName:"tr",align:null},"1-4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Golay Index"),(0,i.kt)("td",{parentName:"tr",align:null},"link"),(0,i.kt)("td",{parentName:"tr",align:null},"yes (synchronized)"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"linkParamsOverrides.[responderMac].fwParams.txGolayIdx"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"linkParamsOverrides.[responderMac].fwParams.rxGolayIdx")),(0,i.kt)("td",{parentName:"tr",align:null},"0-3, 4-7 (copies)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Control Superframe"),(0,i.kt)("td",{parentName:"tr",align:null},"link"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"linkParamsOverrides.[responderMac].fwParams.controlSuperframe")),(0,i.kt)("td",{parentName:"tr",align:null},"0, 1, 255")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Airtime"),(0,i.kt)("td",{parentName:"tr",align:null},"link"),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"linkParamsOverrides.[responderMac].airtimeConfig.*")),(0,i.kt)("td",{parentName:"tr",align:null},"-")))),(0,i.kt)("p",null,"Controller-assigned parameters are stored in the automatic node overrides layer\nof the node configuration (can be overridden by user configuration if required),\nand are accessed and modified via ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigHelper")," (refer to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/developer/Configuration_Management"},"Configuration Management")," for further details)."),(0,i.kt)("p",null,"For firmware parameters which cannot be dynamically changed (i.e. post-config\naction is ",(0,i.kt)("inlineCode",{parentName:"p"},"RELOAD_FIRMWARE"),"), any update to live radios or links will trigger a\nfirmware reload. If dynamic changes must be synchronized across affected links\n(i.e. post-config action is ",(0,i.kt)("inlineCode",{parentName:"p"},"SET_FW_PARAMS_SYNC_OR_RELOAD_FIRMWARE"),"), then the\nchange will be scheduled at a specific BWGD index as determined by the\ncontroller's ",(0,i.kt)("inlineCode",{parentName:"p"},"GpsClock")," time plus a default delay of 5.12 seconds (controller\nflag ",(0,i.kt)("inlineCode",{parentName:"p"},"--firmware_parameter_update_delay"),"), with an additional firmware\nconstraint that no more than 2 parameter updates can be scheduled simultaneously\n(otherwise firmware will be reloaded to apply all changes)."),(0,i.kt)("h3",{id:"polarity"},"Polarity"),(0,i.kt)("p",null,"Polarity validation and assignment is handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"PolarityHelper"),"."),(0,i.kt)("h4",{id:"background"},"Background"),(0,i.kt)("p",null,"Sectors on both ends of a wireless link alternate between transmitting and\nreceiving in complementary time slots. This dramatically reduces interference,\nas nodes only receive very weak interfering signals from at least three hops\naway. To achieve this, each sector is assigned a ",(0,i.kt)("em",{parentName:"p"},"polarity")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"ODD")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"EVEN"),"."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/figures/polarity.svg",width:"400"})),(0,i.kt)("p",null,"This simple assignment scheme requires neighbors in the network graph to have\nopposite polarities, and only works if the graph can be bipartitioned. To\nsupport topologies with odd cycles, ",(0,i.kt)("em",{parentName:"p"},"hybrid polarities")," can be used in two\ndistinct ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Hardware hybrid"),' - A site can contain sectors with different polarities.\nThese are "hardware" hybrids, which use hardware solutions to avoid inter-node\ntransmit and receive interference. However, in a small fraction of cases (on\nthe order of 1%), sectors in close proximity on the same site may still cause\nsignificant self-interference.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Software hybrid"),' - When hardware hybrid solutions are not possible, sectors\ncan instead use time-division multiplexing to alternate between odd and even\npolarities. These "software" hybrids are tagged in E2E as ',(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_ODD")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_EVEN"),", and require special handling by the controller (discussed\nbelow). Software hybrid sectors on a site will access the medium orthogonally,\nresulting in a 50% loss in bandwidth.")),(0,i.kt)("p",null,'In the sections below, "hybrid" will refer to software hybrids unless otherwise\nnoted, since hardware hybrids are not treated differently from regular\npolarities in E2E.'),(0,i.kt)("h4",{id:"validation"},"Validation"),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Nodes on the same site must all be non-hybrid (",(0,i.kt)("inlineCode",{parentName:"li"},"ODD"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"EVEN"),") or hybrid\n(",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_ODD"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_EVEN"),")."),(0,i.kt)("li",{parentName:"ul"},"Wireless links must have different polarity on both ends (",(0,i.kt)("inlineCode",{parentName:"li"},"ODD"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_ODD"),"\nto ",(0,i.kt)("inlineCode",{parentName:"li"},"EVEN"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_EVEN"),")."),(0,i.kt)("li",{parentName:"ul"},"A wireless link cannot have hybrid nodes on both ends."),(0,i.kt)("li",{parentName:"ul"},"P2MP (point to multi-point) nodes, such as Y-street nodes, cannot be hybrid.\nIn other words, hybrid-polarity DNs support only a single DN to DN link.")),(0,i.kt)("p",null,"Polarity is only relevant when links are formed. Thus, unspecified polarities\nare allowed on nodes until a link is added."),(0,i.kt)("h4",{id:"assignment"},"Assignment"),(0,i.kt)("p",null,"When adding a link:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If validation succeeds with the given values, do nothing."),(0,i.kt)("li",{parentName:"ul"},"If both nodes had unspecified polarity, forcibly set one of them (to a site\npolarity if one exists, otherwise arbitrarily)."),(0,i.kt)("li",{parentName:"ul"},"If one node has no other links, set its polarity to the opposite of the other\nnode.")),(0,i.kt)("p",null,"Currently, the controller will not automatically assign a hybrid polarity.\nHybrid polarity must be explicitly set by the user."),(0,i.kt)("h4",{id:"network-wide-reassignment"},"Network-Wide Reassignment"),(0,i.kt)("p",null,"The controller provides a mechanism to perform a network-wide polarity\noptimization, using the ",(0,i.kt)("em",{parentName:"p"},"odd cycle cover (OCC)")," algorithm in ",(0,i.kt)("inlineCode",{parentName:"p"},"OccSolver")," to find\nthe minimum set of hardware hybrid sites required to achieve a bipartite graph.\nThis operation is triggered manually via the ",(0,i.kt)("inlineCode",{parentName:"p"},"TRIGGER_POLARITY_OPTIMIZATION"),"\ncommand."),(0,i.kt)("p",null,"The polarity optimization process has the following features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It respects all user-configured polarities, and will fail if any changes to\nuser overrides are required. This can be overridden by setting the\n",(0,i.kt)("inlineCode",{parentName:"li"},"clearUserPolarityConfig")," flag, informing the algorithm to reset all user\noverrides before attempting a polarity optimization."),(0,i.kt)("li",{parentName:"ul"},"It tries to avoid allocating sites with P2MP radios as hybrids, reducing the\nchance of misconfiguration."),(0,i.kt)("li",{parentName:"ul"},"It tries to honor existing polarity assignments as much as possible, reducing\ndisruption to the network. Currently, changing polarity requires breaking\nlinks."),(0,i.kt)("li",{parentName:"ul"},"It does not allocate any software hybrids unless configured by the user.")),(0,i.kt)("h3",{id:"golay-index"},"Golay Index"),(0,i.kt)("p",null,"Golay index validation and assignment is handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"GolayHelper"),". Note that the\ncontroller will only assign Golay indexes 1 and 2 by default."),(0,i.kt)("h4",{id:"background-1"},"Background"),(0,i.kt)("p",null,"Every packet transmitted over the air in a Terragraph network contains a PHY\nlayer preamble consisting of a ",(0,i.kt)("em",{parentName:"p"},"Short Training Field")," (STF) and a ",(0,i.kt)("em",{parentName:"p"},"Channel\nEstimation Field")," (CEF), as defined in the ",(0,i.kt)("a",{parentName:"p",href:"https://standards.ieee.org/findstds/standard/802.11-2016.html"},"IEEE 802.11-2016")," standard. The\nreceiver uses the STF to detect the presence of a packet in the air and thus\nstart the remainder of the packet acquisition process. Since the same preamble\nis used, irrespective of the Modulation and Coding Set (MCS) used for the data\npayload, the STF is designed to be detectable even at very low signal to noise\nratios (SNR). As a consequence, a weak interfering packet will trigger packet\nacquisition, and any desired packet arriving while the receiver is busy\nattempting to decode the interfering packet will be missed. This is known as\n",(0,i.kt)("em",{parentName:"p"},"early weak interference")," and is especially apparent in Terragraph's current\nTDMA network design."),(0,i.kt)("p",null,"Both the STF and CEF are derived from a 128-bit ",(0,i.kt)("em",{parentName:"p"},"Golay Code Sequence"),". To\nminimize the extent of early weak interference, different Golay Code Sequences\ncan be applied to interfering links so that the receiver will only begin the\npacket acquisition process when it receives the expected preamble."),(0,i.kt)("h4",{id:"validation-1"},"Validation"),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Golay codes on both ends of a link must be identical.")),(0,i.kt)("h4",{id:"assignment-1"},"Assignment"),(0,i.kt)("p",null,"The procedure for assigning Golay codes to new links is detailed in\n",(0,i.kt)("a",{parentName:"p",href:"#topology-management-channel-golay-assignment"},"Algorithms for Channel and Golay Assignment"),"."),(0,i.kt)("h4",{id:"network-wide-reassignment-1"},"Network-Wide Reassignment"),(0,i.kt)("p",null,"The controller provides a mechanism to perform a network-wide Golay reassignment\nto resolve any misconfiguration. This operation is triggered manually via the\n",(0,i.kt)("inlineCode",{parentName:"p"},"TRIGGER_GOLAY_OPTIMIZATION")," command."),(0,i.kt)("p",null,"The reassignment process implements the network-wide reassignment\nprocedure detailed in\n",(0,i.kt)("a",{parentName:"p",href:"#topology-management-channel-golay-assignment"},"Algorithms for Channel and Golay Assignment"),"."),(0,i.kt)("h3",{id:"channel"},"Channel"),(0,i.kt)("p",null,"Channel allocation is handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"ChannelHelper"),". Note that the controller will\nonly use channel 2 unless otherwise configured by the user (via controller\nconfiguration field ",(0,i.kt)("inlineCode",{parentName:"p"},"topologyParams.enabledChannels"),")."),(0,i.kt)("h4",{id:"background-2"},"Background"),(0,i.kt)("p",null,"Terragraph networks utilize the 60GHz (V-Band) spectrum. In many countries,\nV-Band is unlicensed and allows for multiple GHz of RF bandwidth. The amount of\navailable spectrum for use by Terragraph varies depending on local wireless\nregulations. Terragraph supports channels 1, 2, 3, and 4 in the 60GHz band. Each\nchannel, as per the 802.11ad specification, is 2.16GHz wide as shown below."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/figures/spectrum.png",width:"800"}),(0,i.kt)("br",null),(0,i.kt)("em",null,"60GHz band allocation")),(0,i.kt)("h4",{id:"validation-2"},"Validation"),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Channels on all links at a node in point-to-multipoint must be identical."),(0,i.kt)("li",{parentName:"ul"},"Receiver and transmitter channels must be identical.")),(0,i.kt)("h4",{id:"assignment-2"},"Assignment"),(0,i.kt)("p",null,"The procedure for assigning channels to new links is detailed in\n",(0,i.kt)("a",{parentName:"p",href:"#topology-management-channel-golay-assignment"},"Algorithms for Channel and Golay Assignment"),"."),(0,i.kt)("h4",{id:"network-wide-reassignment-2"},"Network-Wide Reassignment"),(0,i.kt)("p",null,"The controller provides a mechanism to perform a network-wide channel\nreassignment to resolve any misconfiguration. This operation is triggered\nmanually via the ",(0,i.kt)("inlineCode",{parentName:"p"},"TRIGGER_CHANNEL_OPTIMIZATION")," command."),(0,i.kt)("p",null,"The reassignment process implements the network-wide reassignment\nprocedure detailed in\n",(0,i.kt)("a",{parentName:"p",href:"#topology-management-channel-golay-assignment"},"Algorithms for Channel and Golay Assignment"),"."),(0,i.kt)("h3",{id:"control-superframe"},"Control Superframe"),(0,i.kt)("p",null,"Control superframe validation and assignment is handled by\n",(0,i.kt)("inlineCode",{parentName:"p"},"ControlSuperframeHelper"),"."),(0,i.kt)("h4",{id:"background-3"},"Background"),(0,i.kt)("p",null,"The control superframe defines the time slot at which both ends of a link\nexchange control information (i.e. keep-alive messages). For context, each\nsuperframe is 1.6ms long and consists of 4 TDD frames. The control superframe is\nan integer that can take values ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"255")," (equivalent to unspecified).\nIn order to transmit control information at non-conflicting time slots, a DN\nsector must use a different control superframe on all of its wireless links to\nother DN sectors. For DN to CN links, the control superframe should be left\nunspecified."),(0,i.kt)("p",null,"Normally, in the P2P (point to point) scenario, the control superframe can be\nleft unspecified and will be handled automatically by the firmware; this is\nequivalent to using the value ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),". However, with P2MP (point to multi-point),\nthe nodes at the opposite ends of the two links have no way to automatically\npick non-conflicting control superframes. The primary role of E2E is to assign\nnon-conflicting values (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") across these links."),(0,i.kt)("h4",{id:"validation-3"},"Validation"),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"All DN to DN links from a sector must have different (i.e. non-conflicting)\nsuperframes. An unspecified value is considered a conflict if multiple DN to\nDN links exist."),(0,i.kt)("li",{parentName:"ul"},"DN to CN links may all have unspecified control superframes (",(0,i.kt)("inlineCode",{parentName:"li"},"255"),")."),(0,i.kt)("li",{parentName:"ul"},"Hybrid polarity DNs have pre-defined control superframe values. Links with\n",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_EVEN")," polarity must use ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," and links with ",(0,i.kt)("inlineCode",{parentName:"li"},"HYBRID_ODD")," must use ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),".")),(0,i.kt)("h4",{id:"assignment-3"},"Assignment"),(0,i.kt)("p",null,"When adding a link:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If control superframe is unspecified on a DN to DN link, set it to ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,i.kt)("li",{parentName:"ul"},"If validation succeeds with the given values, take no other actions (excluding\nthe one above)."),(0,i.kt)("li",{parentName:"ul"},"Attempt reassignment to all acceptable values remaining (",(0,i.kt)("inlineCode",{parentName:"li"},"0")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," for DN to\nDN links; ",(0,i.kt)("inlineCode",{parentName:"li"},"255")," for DN to CN links).")),(0,i.kt)("h4",{id:"network-wide-reassignment-3"},"Network-Wide Reassignment"),(0,i.kt)("p",null,"The controller provides a mechanism to perform a network-wide control superframe\nreassignment to resolve any misconfiguration. This operation is triggered\nmanually via the ",(0,i.kt)("inlineCode",{parentName:"p"},"TRIGGER_CONTROL_SUPERFRAME_OPTIMIZATION")," command."),(0,i.kt)("p",null,"The reassignment process has the following features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It respects all user-configured values, and will fail if any changes to\nuser overrides are required. This can be overridden by setting the\n",(0,i.kt)("inlineCode",{parentName:"li"},"clearUserConfig")," flag, informing the controller to reset all user\noverrides before attempting a reassignment."),(0,i.kt)("li",{parentName:"ul"},"It tries to honor existing control superframe assignments as much as possible,\nreducing disruption to the network. Currently, changing control superframe\nrequires breaking links.")),(0,i.kt)("h3",{id:"airtime"},"Airtime"),(0,i.kt)("p",null,"Airtime allocation is handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"BandwidthAllocationHelper"),"."),(0,i.kt)("h4",{id:"background-4"},"Background"),(0,i.kt)("p",null,"The default airtime allocation on each node can be overridden through the\n",(0,i.kt)("inlineCode",{parentName:"p"},"thrift::NetworkAirtime")," structure, which defines a per-link map of the minimum,\nmaximum, and ideal transmit/receive percentages. This can be used, for instance,\nto enforce fair resource allocation across the network topology."),(0,i.kt)("p",null,"This feature is a work in progress and is not currently enabled."),(0,i.kt)("h4",{id:"allocation"},"Allocation"),(0,i.kt)("p",null,"If automatic airtime allocation is enabled, ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp")," will recompute the\nfair airtime allocation map on startup and whenever the topology is modified.\nThe controller sends any airtime changes to nodes using the ",(0,i.kt)("inlineCode",{parentName:"p"},"SET_NODE_PARAMS"),"\n(",(0,i.kt)("inlineCode",{parentName:"p"},"NETWORK"),") command."),(0,i.kt)("p",null,"The airtime computations currently consider only the network graph and perform\nsimple shortest-paths computations to POP nodes. The algorithm does not yet take\nrouting into account."),(0,i.kt)("a",{id:"topology-management-channel-golay-assignment"}),(0,i.kt)("h3",{id:"algorithms-for-channel-and-golay-assignment"},"Algorithms for Channel and Golay Assignment"),(0,i.kt)("p",null,"The algorithms for assigning channel and Golay codes\nbased on interference estimates are handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"InterferenceHelper"),"."),(0,i.kt)("h4",{id:"assignment-for-new-links"},"Assignment for New Links"),(0,i.kt)("p",null,"There are 4 observed heuristics that affect interference which the\nnew link assignment algorithm attempts to mitigate:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Adjacent links with < 20 degree angles may have interference, regardless of\npolarity."),(0,i.kt)("li",{parentName:"ol"},"Adjacent links with > 50 degree angles do not show much interference."),(0,i.kt)("li",{parentName:"ol"},"Links with > 2 links in between do not have interference."),(0,i.kt)("li",{parentName:"ol"},"Two links with one link in between will have interference (between the\ninitial sector of the first link and last sector of the last link). Thus,\nthere should not be three consecutive links with the same Golay code\nor channel. Additionally, the Golay/channels must not take the form ",(0,i.kt)("inlineCode",{parentName:"li"},"a-b-a"),";\ntheir form should be either ",(0,i.kt)("inlineCode",{parentName:"li"},"a-a-b")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"a-b-b"),".")),(0,i.kt)("p",null,"When adding a link:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Generate a directed graph of all wireless links in the topology and their\nangular differences. Each vertex represents a link in the original network\ngraph, and an edge represents links connected to the same site. Edges also\ntrack the angular difference between a link and its adjacencies."),(0,i.kt)("li",{parentName:"ul"},"Assign the link's Golay code or channel by applying the four heuristics above."),(0,i.kt)("li",{parentName:"ul"},"If, after applying the heuristics, there are no valid options left, simply\nassign one at random.")),(0,i.kt)("p",null,"Currently, only link adjacencies and angle differences are used to assign Golay\ncodes and channels for a new link."),(0,i.kt)("h4",{id:"network-wide-reassignment-4"},"Network-Wide Reassignment"),(0,i.kt)("h5",{id:"identify-all-link-groups"},"Identify all link groups"),(0,i.kt)("p",null,"A set of links belongs to the same ",(0,i.kt)("em",{parentName:"p"},"link group")," if they must all share the same\nGolay code/channel assignment. Links originating from or terminating at the same\nradio are part of the same group. For example, all links forming a z-street\nsetup are part of the same group. The figure below illustrates this concept."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/figures/golay_groups.png",width:"750"})),(0,i.kt)("h5",{id:"estimate-group-interference-matrix"},"Estimate group interference matrix"),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"group-to-group interference estimate")," is the sum of the estimated\ninterference between all links within each group. The controller uses a\ntopology-based approach to estimate the interference between any two nodes. In\nthis approach, distance between nodes, Angle-of-Departure (AoD), and\nAngle-of-Arrival (AoA) are used to estimate the interference experienced by both\nends of a link caused by transmission on another link."),(0,i.kt)("p",null,"For this purpose, the controller assumes perfect alignment between the radio\nand its corresponding link under consideration. Constant transmission power is\nalso assumed across all links. When assigning Golay codes, the controller\nassumes zero interference between links on different channels."),(0,i.kt)("h5",{id:"build-the-group-interference-graph"},"Build the group interference graph"),(0,i.kt)("p",null,"Next, the controller constructs a graph in which the vertices are the\npreviously-identified link groups. An edge is added between any two groups with\na non-zero interference estimate."),(0,i.kt)("p",null,"The resultant graph is the ",(0,i.kt)("em",{parentName:"p"},"group interference graph"),". The task of assigning\nGolay codes/channels to different groups is equivalent to solving the graph\ncoloring problem using a number of colors that is equal to the number of\navailable Golay codes or channels."),(0,i.kt)("p",null,"Since only two orthogonal Golay codes are available for allocation\nthe ",(0,i.kt)("em",{parentName:"p"},"odd cycle cover (OCC)")," algorithm is used to convert the graph into a\nbipartite graph by removing the least number of groups while minimizing the\noverall network interference. This uses the same OCC algorithm as the one for\npolarity optimization. Channel assignment also uses this algorithm to attempt\nto minimize the number of channel allocations that add to the overall\nnetwork interference."),(0,i.kt)("h5",{id:"allocate-golay-codes-or-channels"},"Allocate Golay codes or channels"),(0,i.kt)("p",null,"Any predetermined Golay codes/channels within the node configuration overrides\nare assigned first. These manual configurations can be ignored and overridden by\nsetting the ",(0,i.kt)("inlineCode",{parentName:"p"},"clearUserConfig")," flag."),(0,i.kt)("p",null,"Next, Golay codes/channels are assigned for all groups not identified\nfor exclusion by the OCC algorithm. These groups will form a bipartite graph and\ncan be allocated Golay codes/channels that avoid all interference between them."),(0,i.kt)("p",null,"Finally, Golay codes/channels are assigned for the groups identified by the OCC\nalgorithm. In this case, the Golay code/channel that minimizes the overall\ninterference experienced by the link group is selected."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": The recommended order of optimizations is polarity, then channel,\nthen Golay. This is because the channel assignments depend on polarity, and the\nGolay assignments depend on both polarity and channel."),(0,i.kt)("h2",{id:"network-state"},"Network State"),(0,i.kt)("h3",{id:"node-status"},"Node Status"),(0,i.kt)("p",null,"Node state is managed by ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," on the controller and minion. The minion\nsends ",(0,i.kt)("inlineCode",{parentName:"p"},"STATUS_REPORT")," heartbeats at regular intervals to the controller, and\nincludes details such as its ignition/configuration/upgrade state and\nsoftware/hardware versions in these heartbeats. The controller replies with\n",(0,i.kt)("inlineCode",{parentName:"p"},"STATUS_REPORT_ACK")," acknowledgements. If the minion does not receive any\nacknowledgements or other messages from the controller within a specified\ntimeout period, it will attempt to tear down the current network socket to the\ncontroller and reconnect (refer to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/developer/Communication_Protocol"},"Communication Protocol")," for further details).\nMeanwhile, ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp")," periodically computes all node liveness states based on\nthe last time a heartbeat was received from each node."),(0,i.kt)("p",null,"A node's liveness is derived from its ignition state. The ignition state\nlifecycle differs for DNs and CNs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DN")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"OFFLINE")," \u2192 ",(0,i.kt)("inlineCode",{parentName:"li"},"ONLINE")," \u2192 ",(0,i.kt)("inlineCode",{parentName:"li"},"ONLINE_INITIATOR")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CN")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"OFFLINE")," \u2192 ",(0,i.kt)("inlineCode",{parentName:"li"},"ONLINE"))),(0,i.kt)("p",null,"All nodes initially boot into the ",(0,i.kt)("inlineCode",{parentName:"p"},"OFFLINE")," status. For each radio, the minion's\n",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," sends a ",(0,i.kt)("inlineCode",{parentName:"p"},"NODE_INIT")," message to its ",(0,i.kt)("inlineCode",{parentName:"p"},"DriverApp")," containing initial\nfirmware parameters, then starts sending heartbeats to the controller upon\nreceiving any ",(0,i.kt)("inlineCode",{parentName:"p"},"NODE_INIT_NOTIFY")," success notification from ",(0,i.kt)("inlineCode",{parentName:"p"},"DriverApp"),". The\nminion then sends a ",(0,i.kt)("inlineCode",{parentName:"p"},"FW_SET_NODE_PARAMS")," message to the driver with polarity,\nchannel, and airtime parameters from its node configuration (if present), and\nalso a ",(0,i.kt)("inlineCode",{parentName:"p"},"GPS_ENABLE_REQ")," message to enable GPS (if applicable; read below)."),(0,i.kt)("p",null,"When the controller's ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," receives a heartbeat from a node with an\n",(0,i.kt)("inlineCode",{parentName:"p"},"OFFLINE")," status, it sends a ",(0,i.kt)("inlineCode",{parentName:"p"},"SET_NODE_PARAMS_REQ")," request to ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp"),",\nwhich then sends ",(0,i.kt)("inlineCode",{parentName:"p"},"SET_NODE_PARAMS")," (",(0,i.kt)("inlineCode",{parentName:"p"},"INIT"),") message(s) to the minion's\n",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," (one message per WLAN MAC address). Upon receipt, the minion marks\nitself as ",(0,i.kt)("inlineCode",{parentName:"p"},"ONLINE")," (if GPS is disabled) or ",(0,i.kt)("inlineCode",{parentName:"p"},"ONLINE_INITIATOR")," (if GPS was\nalready enabled). If the node had not already configured its polarity, channel,\netc. during initialization (i.e. the parameters are not in the node's local\nconfiguration file), it does so now with the parameters sent from the\ncontroller. The controller's ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," will also request the status of the\nnode's wireless links at this time."),(0,i.kt)("p",null,"For DNs, transitioning to ",(0,i.kt)("inlineCode",{parentName:"p"},"ONLINE_INITIATOR")," requires enabling GPS to achieve\ntime synchronization. This requires knowledge of the node's physical site\nlocation. Periodically, ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp")," looks for DNs that are ",(0,i.kt)("inlineCode",{parentName:"p"},"ONLINE")," and does\nthe following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the node's site location accuracy is within 50 meters\n(",(0,i.kt)("inlineCode",{parentName:"li"},"E2EConsts::kGpsAccuracyThresh"),", required for GPS time estimation within\n500ns) ",(0,i.kt)("em",{parentName:"li"},"or")," the ",(0,i.kt)("inlineCode",{parentName:"li"},"forceGpsDisable")," firmware config flag is set, the controller\nsends a ",(0,i.kt)("inlineCode",{parentName:"li"},"SET_NODE_PARAMS")," (",(0,i.kt)("inlineCode",{parentName:"li"},"GPS"),") message to the minion's ",(0,i.kt)("inlineCode",{parentName:"li"},"StatusApp"),". Upon\nreceipt, the minion sends a ",(0,i.kt)("inlineCode",{parentName:"li"},"GPS_ENABLE_REQ")," to the driver, and marks itself\nas ",(0,i.kt)("inlineCode",{parentName:"li"},"ONLINE_INITIATOR")," after receiving a ",(0,i.kt)("inlineCode",{parentName:"li"},"FW_ACK")," (",(0,i.kt)("inlineCode",{parentName:"li"},"GPS_ENABLE_REQ"),")\nacknowledgement that the GPS was successfully enabled."),(0,i.kt)("li",{parentName:"ul"},"If the node's location is too inaccurate, the controller sends a\n",(0,i.kt)("inlineCode",{parentName:"li"},"GPS_GET_POS_REQ")," message to the minion's ",(0,i.kt)("inlineCode",{parentName:"li"},"StatusApp"),", which forwards it to\nthe driver. The minion responds with its current GPS position\n(",(0,i.kt)("inlineCode",{parentName:"li"},"GPS_GET_POS_RESP"),"), and the controller uses this to update its topology\ninformation only if the newly-reported location is more accurate than the\nexisting one.")),(0,i.kt)("h3",{id:"link-status"},"Link Status"),(0,i.kt)("p",null,"Wireless link state is managed by ",(0,i.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," on the controller and minion.\nEvery time the status of a wireless link changes, the minion sends a\n",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_STATUS")," message to ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp"),". In some cases, the controller's\n",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IgnitionApp"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," will actively request a link status\nby sending a ",(0,i.kt)("inlineCode",{parentName:"p"},"GET_LINK_STATUS")," message. If the controller receives a ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP"),"\nevent for a link which does not exist in the current topology, it will\nforcefully disassociate the link. When the controller receives a ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_DOWN"),"\nevent for a DN-to-DN link where either side is a P2MP DN with other active\nlinks, it will disable BF responder mode to avoid throughput loss on these\nlinks. Refer to ",(0,i.kt)("a",{parentName:"p",href:"/docs/developer/Network_Ignition"},"Network Ignition")," for further details\nabout the link ignition process."),(0,i.kt)("p",null,"Wired intra-site link state is maintained by ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," on the controller and\nminion. Each minion's status report contains status of its wired connections.\nWhen this status changes, the controller's ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," sends a\n",(0,i.kt)("inlineCode",{parentName:"p"},"SET_WIRED_LINK_STATUS")," message to ",(0,i.kt)("inlineCode",{parentName:"p"},"TopologyApp"),". Wired inter-site link state is\nnot checked, and these links will always appear as alive."),(0,i.kt)("h3",{id:"gps-time-synchronization"},"GPS Time Synchronization"),(0,i.kt)("p",null,"The controller uses its local clock for scheduling (e.g. scan commands, firmware\nconfiguration changes). To ensure its clock is synchronized with GPS-based node\nclocks, the controller updates its clock based on GPS timestamps sent from each\nnode."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"GpsClock")," is a custom clock used to hold GPS time. It is designed to receive\nperiodic updates from an accurate GPS source, and fill in the remaining\nintervals using a ",(0,i.kt)("inlineCode",{parentName:"p"},"std::chrono::steady_clock")," delta since the last GPS time was\nreceived."),(0,i.kt)("h4",{id:"minion-procedure"},"Minion Procedure"),(0,i.kt)("p",null,"The node firmware attaches the current GPS timestamp to periodic ",(0,i.kt)("inlineCode",{parentName:"p"},"FW_HEALTHY"),"\nmessages sent to minion. The minion's ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," uses this timestamp to update\nits ",(0,i.kt)("inlineCode",{parentName:"p"},"GpsClock")," instance directly (assuming no significant latency on message\npassing), and sends GPS time to the controller in periodic status reports\n(",(0,i.kt)("inlineCode",{parentName:"p"},"STATUS_REPORT")," messages)."),(0,i.kt)("h4",{id:"controller-procedure"},"Controller Procedure"),(0,i.kt)("p",null,"Upon receipt of a GPS timestamp, the controller's ",(0,i.kt)("inlineCode",{parentName:"p"},"StatusApp")," uses\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cristian%27s_algorithm"},"Cristian's algorithm")," to address network latency. Nodes are considered the time\nservers, and the controller is considered the client. The latency in both\ndirections is assumed to be symmetric. The latency correction algorithm is\ndescribed below."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The controller records the GPS time of the last status report received from\neach node (as ",(0,i.kt)("em",{parentName:"li"},"t1"),"), then sends an acknowledgement to the minion."),(0,i.kt)("li",{parentName:"ol"},"The minion records the GPS timestamp of the latest status report\nacknowledgement it received from the controller (as ",(0,i.kt)("em",{parentName:"li"},"t2"),")."),(0,i.kt)("li",{parentName:"ol"},"When sending a status report to the controller, the minion includes its\ncurrent GPS time (as ",(0,i.kt)("em",{parentName:"li"},"t3"),") as well as the GPS timestamp of the latest status\nreport acknowledgement it received (",(0,i.kt)("em",{parentName:"li"},"t2"),"). The controller subtracts out the\ntime delay between ",(0,i.kt)("em",{parentName:"li"},"t2")," and ",(0,i.kt)("em",{parentName:"li"},"t3")," when computing the round-trip time."),(0,i.kt)("li",{parentName:"ol"},"On receipt of a status report, the controller records its current GPS time\n(as ",(0,i.kt)("em",{parentName:"li"},"t4"),"). Then, it uses the recorded timestamp values to add a latency\ncorrection to the GPS timestamp reported by the node (",(0,i.kt)("em",{parentName:"li"},"t3"),") as follows:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Round-trip time = rtt = (t4 - t1) - (t3 - t2)\nLatency of response = latency = rtt / 2\nLatency-corrected GPS time = t3 + latency\n")),(0,i.kt)("p",null,"As the controller collects a series of timestamps from nodes, it uses\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Chauvenet%27s_criterion"},"Chauvenet's criterion")," to determine if incoming timestamps are outliers. The\nalgorithm used to determine if a timestamp is an outlier is described below."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"On receipt of a GPS timestamp, calculate the delta between the timestamp\n(after applying Cristian's algorithm to correct for latency) and the\ncontroller's GPS clock."),(0,i.kt)("li",{parentName:"ol"},"Calculate the mean and standard deviation of the list of existing timestamps\nthat the controller has stored."),(0,i.kt)("li",{parentName:"ol"},"Use a normal distribution to calculate the probability of seeing the\ntimestamp that just arrived, based off of the mean and standard deviation\ncalculated above."),(0,i.kt)("li",{parentName:"ol"},"Apply Chauvenet's criterion to determine if the timestamp is an outlier.\nMultiply the probability of seeing the timestamp by the number of past\ntimestamps the controller is tracking. If this value is less than 0.5, the\ntimestamp is considered an outlier."),(0,i.kt)("li",{parentName:"ol"},"Add the timestamp to the list of timestamps stored on the controller."),(0,i.kt)("li",{parentName:"ol"},"If the new timestamp is not an outlier, use it to set the controller's\n",(0,i.kt)("inlineCode",{parentName:"li"},"GpsClock")," epoch.")),(0,i.kt)("p",null,"Chauvenet's criterion is not applied until at least 6 timestamps have arrived\n(",(0,i.kt)("inlineCode",{parentName:"p"},"FLAGS_min_gps_timestamp_queue_size"),"). The controller only tracks the last 20\ntimestamps (",(0,i.kt)("inlineCode",{parentName:"p"},"FLAGS_max_gps_timestamp_queue_size"),")."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://standards.ieee.org/findstds/standard/802.11-2016.html"},"IEEE 802.11-2016")," - IEEE 802.11-2016 standard"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/rfc4632"},"CIDR")," - Classless Inter-domain Routing (RFC 4632)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Cristian%27s_algorithm"},"Cristian's algorithm")," - Clock synchronization algorithm"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Chauvenet%27s_criterion"},"Chauvenet's criterion")," - Outlier detection criterion")))}m.isMDXComponent=!0}}]);