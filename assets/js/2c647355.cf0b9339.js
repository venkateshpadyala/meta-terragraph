"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3027],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(t),m=r,u=h["".concat(l,".").concat(m)]||h[m]||c[m]||i;return t?a.createElement(u,o(o({ref:n},d),{},{components:t})):a.createElement(u,o({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},2243:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={},o="Overview",s={unversionedId:"developer/Overview",id:"developer/Overview",title:"Overview",description:"Terragraph is a technology that leverages 60 GHz spectrum to deliver fast,",source:"@site/../docs/developer/Overview.md",sourceDirName:"developer",slug:"/developer/Overview",permalink:"/docs/developer/Overview",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Overview.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"Terragraph Developer Manual",permalink:"/docs/developer/"},next:{title:"Communication Protocol",permalink:"/docs/developer/Communication_Protocol"}},l={},p=[{value:"Architecture",id:"architecture",level:2},{value:"Communication Protocol",id:"communication-protocol",level:4},{value:"Routing Layer",id:"routing-layer",level:4},{value:"Driver Interface",id:"driver-interface",level:4},{value:"Driver Stack",id:"driver-stack",level:4},{value:"VPP Implementation",id:"vpp-implementation",level:4},{value:"Timing and Synchronization",id:"timing-and-synchronization",level:4},{value:"PTP &amp; SyncE",id:"ptp--synce",level:4},{value:"Wi-Fi",id:"wi-fi",level:4},{value:"Firmware Layer",id:"firmware-layer",level:2},{value:"Beamforming and Link Adaptation",id:"beamforming-and-link-adaptation",level:4},{value:"MAC &amp; PHY Specification",id:"mac--phy-specification",level:4},{value:"PHY Algorithms",id:"phy-algorithms",level:4},{value:"Firmware Stats",id:"firmware-stats",level:4},{value:"End-to-End (E2E) Service",id:"end-to-end-e2e-service",level:2},{value:"Topology Management",id:"topology-management",level:4},{value:"Network Ignition",id:"network-ignition",level:4},{value:"Software Upgrade",id:"software-upgrade",level:4},{value:"Configuration Management",id:"configuration-management",level:4},{value:"Scans",id:"scans",level:4},{value:"Network Measurements",id:"network-measurements",level:4},{value:"Prefix Allocation",id:"prefix-allocation",level:4},{value:"Topology Discovery",id:"topology-discovery",level:4},{value:"Application Layer Modules",id:"application-layer-modules",level:2},{value:"Stats, Events, Logs",id:"stats-events-logs",level:4},{value:"Terragraph CLI",id:"terragraph-cli",level:4},{value:"API Service",id:"api-service",level:4},{value:"Local Web Interface",id:"local-web-interface",level:4},{value:"LED Agent",id:"led-agent",level:4},{value:"System Management",id:"system-management",level:2},{value:"Service Scripts",id:"service-scripts",level:4},{value:"Watchdog",id:"watchdog",level:4},{value:"High Availability",id:"high-availability",level:4},{value:"Security",id:"security",level:4},{value:"Version Control",id:"version-control",level:2},{value:"Release Conventions",id:"release-conventions",level:4},{value:"Firmware Versioning",id:"firmware-versioning",level:4},{value:"Resources",id:"resources",level:2}],d={toc:p};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Terragraph is a technology that leverages 60 GHz spectrum to deliver fast,\nreliable internet. The documents below serve as a detailed reference for many\nlayers of the Terragraph stack."),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("h4",{id:"communication-protocol"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Communication_Protocol"},"Communication Protocol")),(0,r.kt)("p",null,"Terragraph uses ",(0,r.kt)("a",{parentName:"p",href:"http://zeromq.org/"},"ZeroMQ")," (or ZMQ) for all inter- and intra-process message\npassing at the application layer. Messages are serialized using the ",(0,r.kt)("a",{parentName:"p",href:"https://thrift.apache.org/"},"Thrift"),"\nprotocol, then transported using ZMQ sockets over TCP/IP. In general, all\ncommunication is asynchronous."),(0,r.kt)("h4",{id:"routing-layer"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Routing_Layer"},"Routing Layer")),(0,r.kt)("p",null,"Terragraph uses ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/openr"},"Open/R")," as its routing platform. The core module in Open/R is\nthe distributed, eventually-consistent key-value store, named ",(0,r.kt)("inlineCode",{parentName:"p"},"KvStore"),", which\nis used to disseminate information such as routing adjacencies and network\nprefixes across the entire network; this is used to implement a link-state\nrouting protocol. Each Terragraph node runs an ",(0,r.kt)("inlineCode",{parentName:"p"},"openr")," process."),(0,r.kt)("h4",{id:"driver-interface"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Driver_Interface"},"Driver Interface")),(0,r.kt)("p",null,"The interface between user space applications and the Terragraph driver and\nfirmware is referred to as the ",(0,r.kt)("em",{parentName:"p"},"driver interface")," (",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if"),"). ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if"),"\nnormally runs alongside the E2E minion, and translates between Thrift messages\n(user space) and Netlink messages (driver). Additionally, Terragraph provides\ncommand-line interfaces to communicate with ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," directly."),(0,r.kt)("h4",{id:"driver-stack"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Driver_Stack"},"Driver Stack")),(0,r.kt)("p",null,"The driver stack consists of the Terragraph driver and a wireless driver. Among\nother things, these drivers are responsible for configuring transmit and receive\npaths for the wireless devices, creating virtual network interfaces on the host,\nand handling Netlink messages sent from ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if"),", e.g. by passing requests\nand responses to and from the firmware. Terragraph implements its datapath using\n",(0,r.kt)("a",{parentName:"p",href:"https://www.dpdk.org/"},"DPDK"),", a framework for fast packet processing in user space."),(0,r.kt)("h4",{id:"vpp-implementation"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/VPP_Implementation"},"VPP Implementation")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://wiki.fd.io/view/VPP"},"VPP")," is used with DPDK to implement Terragraph's datapath."),(0,r.kt)("h4",{id:"timing-and-synchronization"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Timing_Synchronization"},"Timing and Synchronization")),(0,r.kt)("p",null,'Terragraph networks are precisely time-synchronized using GPS or an\n"over-the-air sync" mechanism.'),(0,r.kt)("h4",{id:"ptp--synce"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/PTP_SyncE"},"PTP & SyncE")),(0,r.kt)("p",null,"Using specialized Puma hardware, Terragraph software supports 1588v2 Transparent\nClock (Class A/B) and SyncE protocols to meet the synchronization requirements\nof cellular networks."),(0,r.kt)("h4",{id:"wi-fi"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/WiFi"},"Wi-Fi")),(0,r.kt)("p",null,"Puma uses an ESP32 module for Wi-Fi access, and enables TCP/IP using SLIP. Wi-Fi\nis only used for administrative purposes."),(0,r.kt)("h2",{id:"firmware-layer"},"Firmware Layer"),(0,r.kt)("p",null,"Protocols and algorithms implemented in Terragraph firmware are documented\nbelow."),(0,r.kt)("h4",{id:"beamforming-and-link-adaptation"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Beamforming_Link_Adaptation"},"Beamforming and Link Adaptation")),(0,r.kt)("p",null,"Beamforming (BF) is the process of using signal propagation information between\ntwo antennas and modifying antenna characteristics to maximize the signal\nquality between those antennas."),(0,r.kt)("h4",{id:"mac--phy-specification"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/MAC_PHY_Specification"},"MAC & PHY Specification")),(0,r.kt)("p",null,"Terragraph's link protocol is based on IEEE 802.11-2016, and uses a modified\nDirected Multigigabit (DMG) physical layer (PHY) and a significantly slimmed\ndown Media Access Control (MAC) layer."),(0,r.kt)("h4",{id:"phy-algorithms"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/PHY_Algorithms"},"PHY Algorithms")),(0,r.kt)("p",null,"Several physical layer (PHY) algorithms can be tuned via knobs in the node\nconfiguration."),(0,r.kt)("h4",{id:"firmware-stats"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Firmware_Stats"},"Firmware Stats")),(0,r.kt)("p",null,"Terragraph firmware exports a broad set of statistics to aid debugging."),(0,r.kt)("h2",{id:"end-to-end-e2e-service"},"End-to-End (E2E) Service"),(0,r.kt)("p",null,"The End-to-End (E2E) service sits at the application layer, and handles\nimportant management functions such as link bring-up, software upgrades,\nconfiguration management, and more. Terragraph networks are managed by a\ncentralized cloud controller (",(0,r.kt)("inlineCode",{parentName:"p"},"e2e_controller"),"), and each Terragraph node runs a\nlightweight client (",(0,r.kt)("inlineCode",{parentName:"p"},"e2e_minion"),") that connects to the controller. The\ncontroller can run on any host with a route to the Terragraph network, including\na Terragraph node itself."),(0,r.kt)("p",null,'The primary features of the E2E service are listed below. In general, each\nlogical management feature resides in its own class, which is referred to as an\n"app". Each app runs in a separate thread. Functionally, these threads are\nsimple event loops, and process messages (such as commands) one at a time. Both\nthe controller and minion share this design. Source code documentation can be\ngenerated via ',(0,r.kt)("a",{parentName:"p",href:"https://www.doxygen.nl/"},"Doxygen")," (see ",(0,r.kt)("inlineCode",{parentName:"p"},"src/terragraph-e2e/e2e/Doxyfile"),")."),(0,r.kt)("h4",{id:"topology-management"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Topology_Management"},"Topology Management")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"TopologyApp")," holds and manages the network topology, a structure containing\nall details about nodes and links within the network. The topology must be\nprovided upon starting the controller, but the app also exposes APIs to add,\nedit, and delete topology elements during runtime. The app performs thorough\nvalidation of all requested topology changes, allocates prefixes for nodes, and\ncontains several algorithms to automatically assign node and link parameters\nsuch as polarity, Golay codes, channel, and control superframes."),(0,r.kt)("p",null,"In addition, ",(0,r.kt)("inlineCode",{parentName:"p"},"TopologyApp")," records dynamic topology properties, such as node and\nlink liveness and nodes' routing adjacencies. Liveness is determined from the\npresence or absence of periodic status reports from nodes, handled by\n",(0,r.kt)("inlineCode",{parentName:"p"},"StatusApp")," on both the controller and minion."),(0,r.kt)("h4",{id:"network-ignition"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Network_Ignition"},"Network Ignition")),(0,r.kt)("p",null,"On the controller, ",(0,r.kt)("inlineCode",{parentName:"p"},"IgnitionApp"),' is responsible for bringing up (or "igniting")\nlinks in the network. Ignition involves forming a link from an "initiator" node,\nwhich is already connected to the controller, to a "responder" node. Under the\ndefault "auto-ignition" configuration, the app will automatically ignite links\nduring network startup and whenever nodes or links subsequently fail. It applies\nan algorithm on the current topology state to determine ignition order; multiple\nlinks can be ignited in parallel.'),(0,r.kt)("p",null,"The minion's ",(0,r.kt)("inlineCode",{parentName:"p"},"IgnitionApp"),' exchanges ignition-related messages with the driver.\nThere are two distinct flows based on whether link-layer encryption ("wsec") is\nturned on or off. If wsec is enabled, the app is additionally responsible for\nmanaging two additional Linux processes for each wireless interface: an\n"authenticator" (',(0,r.kt)("inlineCode",{parentName:"p"},"hostapd"),') on the initiator node and a "supplicant"\n(',(0,r.kt)("inlineCode",{parentName:"p"},"wpa_supplicant"),") on the responder node."),(0,r.kt)("h4",{id:"software-upgrade"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Software_Upgrade"},"Software Upgrade")),(0,r.kt)("p",null,"The controller manages in-band software upgrades through ",(0,r.kt)("inlineCode",{parentName:"p"},"UpgradeApp"),'. Upgrades\nconsist of two phases: "prepare" and "commit". In the "prepare" phase, the\ncontroller distributes the new software image to nodes, over either BitTorrent\nor HTTP; upon completion, the nodes will flash the new image onto a secondary\ndisk partition. The "commit" command simply instructs nodes to reboot to the\nnewly-written partition.'),(0,r.kt)("p",null,"The main complication for in-band upgrades is that node reboots will bring down\nall links to and from a node, which can affect reachability to the rest of the\nnetwork. The controller's ",(0,r.kt)("inlineCode",{parentName:"p"},"UpgradeApp"),' includes a scheduling algorithm that\nparallelizes commits (in "batches" of nodes) while minimizing network isolation,\nalong with a retry mechanism to handle failures during any upgrade step. The\nminion\'s ',(0,r.kt)("inlineCode",{parentName:"p"},"UpgradeApp")," is responsible for obtaining, validating, and flashing the\nnew software images, and reporting the node's current upgrade status to the\ncontroller."),(0,r.kt)("h4",{id:"configuration-management"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Configuration_Management"},"Configuration Management")),(0,r.kt)("p",null,'Terragraph utilizes a centralized node configuration manager and a layered\nconfiguration model. Initially, nodes start with a version-dependent\n"base configuration", which holds all default config values based on the node\'s\nsoftware version; this is static and bundled with the software image. The\n"network-wide overrides" layer is applied above the base configuration, and\ncontains any config values that should be overridden uniformly across the\nnetwork. The topmost layer, the "node-specific overrides", applies to individual\nnodes. All node configuration files are stored as JSON-serialized Thrift\nstructures. A separate metadata file describes all available configs, their\nvalidation (e.g. type and range checking), and any node actions required\nfollowing a value change (e.g. reboot).'),(0,r.kt)("p",null,"The controller's ",(0,r.kt)("inlineCode",{parentName:"p"},"ConfigApp")," exposes GET/SET operations on all override layers,\nand enforces validation on SET methods. The minion's ",(0,r.kt)("inlineCode",{parentName:"p"},"ConfigApp"),' processes new\nconfig from the controller and takes any associated actions. To keep config in\nsync, nodes send a hash of their local config to the controller in their\nperiodic status reports, and the controller will overwrite a node\'s config upon\nreceiving a mismatch (unless the config is marked as "unmanaged").'),(0,r.kt)("h4",{id:"scans"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Scans"},"Scans")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ScanApp"),' is responsible for initiating scans on nodes and collecting the\nmeasurement results. There are several scan types. For instance,\n"Periodic Beamforming" (PBF) scans identify independent RF paths between pairs\nof nodes; these scans are uni-directional, and run between nodes with L1/L2\nconnectivity. "Interference Measurement" (IM) scans measure interference between\nlinks, and involve a single transmitter and multiple receivers.'),(0,r.kt)("p",null,"Scans are scheduled by the controller to run periodically and in parallel, using\na graph coloring algorithm in ",(0,r.kt)("inlineCode",{parentName:"p"},"ScanScheduler")," and a slot scheduling mechanism in\n",(0,r.kt)("inlineCode",{parentName:"p"},"SchedulerApp"),". The minion simply passes controller commands to the driver, and\nreturns results from the driver to the controller."),(0,r.kt)("h4",{id:"network-measurements"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Network_Measurements"},"Network Measurements")),(0,r.kt)("p",null,"The controller can initiate and manage network performance measurements through\n",(0,r.kt)("inlineCode",{parentName:"p"},"TrafficApp"),". The app supports running ping and iPerf sessions, and dispatches\ncommands to each participating minion's ",(0,r.kt)("inlineCode",{parentName:"p"},"TrafficApp")," to start or stop these\nprocesses. The controller is responsible for maintaining the state of each\nsession and handling the outputs."),(0,r.kt)("h4",{id:"prefix-allocation"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Prefix_Allocation"},"Prefix Allocation")),(0,r.kt)("p",null,"Terragraph nodes can be allocated IPv6 prefixes in three different ways.\nDistributed prefix allocation is when the nodes allocate prefixes amongst\nthemselves using a distributed allocation scheme and is handled entirely by\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/openr"},"Open/R"),". Centralized prefix allocation (CPA) is a scheme where the controller\nallocates prefixes to all the nodes. This scheme linearly scans through the\nprefix range and assigns unallocated prefixes to nodes. CPA serves mostly as a\nstepping stone for more advanced allocation schemes such as Deterministic prefix\nallocation (DPA). DPA involves segmenting the network into prefix zones, which\nare assigned subnet prefixes of the network seed prefix. Nodes will be allocated\nprefixes from their zone's prefixes, allowing the POPs to advertise these\nsubnets to their BGP peers and load-balance ingress traffic."),(0,r.kt)("h4",{id:"topology-discovery"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Topology_Discovery"},"Topology Discovery")),(0,r.kt)("p",null,"Terragraph provides the capability to automatically discover the network\ntopology through the use of a broadcast beamforming protocol. The high-level\ndiscovery algorithm is orchestrated by the controller's ",(0,r.kt)("inlineCode",{parentName:"p"},"TopologyBuilderApp"),",\nwhich extends the topology by incrementally adding and establishing links to\nresponding nodes."),(0,r.kt)("h2",{id:"application-layer-modules"},"Application Layer Modules"),(0,r.kt)("p",null,"Several additional application-layer modules are described below."),(0,r.kt)("h4",{id:"stats-events-logs"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Stats_Events_Logs"},"Stats, Events, Logs")),(0,r.kt)("p",null,"Terragraph includes a separate pipeline for pushing node statistics, events, and\nlogs via several processes running on each node. These are typically aggregated\nusing Kafka and Fluentd servers."),(0,r.kt)("h4",{id:"terragraph-cli"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Terragraph_CLI"},"Terragraph CLI")),(0,r.kt)("p",null,"Terragraph provides command-line interfaces, ",(0,r.kt)("inlineCode",{parentName:"p"},"tg2")," (Lua-based) and ",(0,r.kt)("inlineCode",{parentName:"p"},"tg"),"\n(Python-based), to interact with various Terragraph software components."),(0,r.kt)("h4",{id:"api-service"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/API_Service"},"API Service")),(0,r.kt)("p",null,"Terragraph also provides a REST API service, ",(0,r.kt)("inlineCode",{parentName:"p"},"api_service"),", written in C++ using\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/proxygen"},"Proxygen"),". API Service translates HTTP/JSON requests into ZMQ/Thrift calls to\nthe controller or aggregator, then returns the responses to the client\nJSON-encoded. Documentation is generated from Javadoc-style annotations in the\nsource code using ",(0,r.kt)("a",{parentName:"p",href:"http://apidocjs.com/"},"apiDoc"),", and is statically hosted on the Proxygen server."),(0,r.kt)("h4",{id:"local-web-interface"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Local_Web_Interface"},"Local Web Interface")),(0,r.kt)("p",null,"Terragraph provides a proof-of-concept web portal that is accessible over Wi-Fi,\nwith the primary purpose of enabling easy initial setup. This consists of two\ncomponents: a web server (",(0,r.kt)("inlineCode",{parentName:"p"},"webui"),") and UI (",(0,r.kt)("inlineCode",{parentName:"p"},"tg95"),")."),(0,r.kt)("h4",{id:"led-agent"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/LED_Agent"},"LED Agent")),(0,r.kt)("p",null,"On Puma hardware, ",(0,r.kt)("inlineCode",{parentName:"p"},"led-agent")," controls three LED lights to display basic health\ninformation."),(0,r.kt)("h2",{id:"system-management"},"System Management"),(0,r.kt)("p",null,"The following features are included with Terragraph to assist with system\nmanagement."),(0,r.kt)("h4",{id:"service-scripts"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Service_Scripts"},"Service Scripts")),(0,r.kt)("p",null,"Terragraph includes scripts to manage its processes using ",(0,r.kt)("a",{parentName:"p",href:"https://www.freedesktop.org/wiki/Software/systemd/"},"systemd")," on x86 hosts\n(e.g. controller) and ",(0,r.kt)("a",{parentName:"p",href:"http://smarden.org/runit/"},"runit")," on nodes. The service scripts perform all required\nenvironment setup and cleanup for each process. The service managers handle\nother tasks such as logging and automatic process restarts."),(0,r.kt)("h4",{id:"watchdog"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Watchdog"},"Watchdog")),(0,r.kt)("p",null,"Terragraph nodes contain watchdog processes which detect, repair, and log\nvarious faults. Kernel crashes (panics) are also logged."),(0,r.kt)("h4",{id:"high-availability"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/High_Availability"},"High Availability")),(0,r.kt)("p",null,'The controller supports a high-availability configuration using a primary-backup\nprotocol. In this setup, two controllers (or "peers") are run on separate\nmachines, and are designated as either "primary" or "backup". If the primary\ncatastrophically fails (e.g. power outage, network failure, hardware failure,\netc.), the backup will assume control of the Terragraph network.'),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BinaryStarApp")," manages the underlying finite state machine (FSM), heartbeating\nwith the peer via a dedicated socket, and data synchronization with the peer\nand local apps. Some additional logic resides in the controller's and minion's\n",(0,r.kt)("inlineCode",{parentName:"p"},"Broker")," for failover scenarios."),(0,r.kt)("h4",{id:"security"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Security"},"Security")),(0,r.kt)("p",null,"Terragraph wireless links and wired CPE interfaces can be secured using the IEEE\n802.1X standard. Nodes can also apply ",(0,r.kt)("inlineCode",{parentName:"p"},"ip6tables")," firewall rules via node\nconfiguration."),(0,r.kt)("h2",{id:"version-control"},"Version Control"),(0,r.kt)("p",null,"Information about code versioning is provided below."),(0,r.kt)("h4",{id:"release-conventions"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Release_Conventions"},"Release Conventions")),(0,r.kt)("p",null,"Terragraph manages its code repository using Git, and releases software with\nmajor and minor versions."),(0,r.kt)("h4",{id:"firmware-versioning"},(0,r.kt)("a",{parentName:"h4",href:"/docs/developer/Firmware_Versioning"},"Firmware Versioning")),(0,r.kt)("p",null,"Terragraph's wireless firmware is versioned separately from Terragraph software."),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://zeromq.org/"},"ZeroMQ")," - Distributed messaging library"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://thrift.apache.org/"},"Thrift")," - Meta's interface definition language"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/openr"},"Open/R")," - Meta's routing platform"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.dpdk.org/"},"DPDK")," - Data Plane Development Kit"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://wiki.fd.io/view/VPP"},"VPP")," - Vector Packet Processing"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.doxygen.nl/"},"Doxygen")," - Documentation generator"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.freedesktop.org/wiki/Software/systemd/"},"systemd")," - Linux init system with service management"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://smarden.org/runit/"},"runit")," - UNIX init scheme with service supervision"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/proxygen"},"Proxygen")," - Meta's C++ HTTP libraries"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://apidocjs.com/"},"apiDoc")," - Documentation generator for REST APIs")))}c.isMDXComponent=!0}}]);