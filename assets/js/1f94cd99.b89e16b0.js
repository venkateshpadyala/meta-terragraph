"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1637],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(n),c=r,g=u["".concat(s,".").concat(c)]||u[c]||m[c]||i;return n?a.createElement(g,l(l({ref:t},p),{},{components:n})):a.createElement(g,l({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4466:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={},l="Timing and Synchronization",o={unversionedId:"developer/Timing_Synchronization",id:"developer/Timing_Synchronization",title:"Timing and Synchronization",description:"This document describes Terragraph's architecture for time synchronization.",source:"@site/../docs/developer/Timing_Synchronization.md",sourceDirName:"developer",slug:"/developer/Timing_Synchronization",permalink:"/docs/developer/Timing_Synchronization",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Timing_Synchronization.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"VPP Implementation",permalink:"/docs/developer/VPP_Implementation"},next:{title:"PTP & SyncE",permalink:"/docs/developer/PTP_SyncE"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"GPS",id:"gps",level:3},{value:"OTA Sync",id:"ota-sync",level:3},{value:"Timing and Synchronization",id:"timing-and-synchronization-1",level:2},{value:"Synchronization State Machine",id:"synchronization-state-machine",level:3},{value:"Time Sample Validity",id:"time-sample-validity",level:3},{value:"Timing Constraints",id:"timing-constraints",level:3},{value:"Timing Correction",id:"timing-correction",level:3},{value:"PPS Sync State",id:"pps-sync-state",level:4},{value:"RF Sync State",id:"rf-sync-state",level:4},{value:"Ignition and Link Management",id:"ignition-and-link-management",level:2},{value:"E2E Controller and GPS Survey-In",id:"e2e-controller-and-gps-survey-in",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Terragraph Hardware",id:"terragraph-hardware",level:3},{value:"Rev5 Hardware",id:"rev5-hardware",level:4},{value:"Puma Hardware",id:"puma-hardware",level:4},{value:"Puma MBH Hardware",id:"puma-mbh-hardware",level:4},{value:"GPS Porting Guide",id:"gps-porting-guide",level:3},{value:"Constraints",id:"constraints",level:4},{value:"Code Changes",id:"code-changes",level:4},{value:"GPS Stats",id:"gps-stats",level:2},{value:"Firmware Stats",id:"firmware-stats",level:3},{value:"Driver Stats",id:"driver-stats",level:3},{value:"Node Configuration",id:"node-configuration",level:2},{value:"OTA Sync Deployment Notes",id:"ota-sync-deployment-notes",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Example Scenarios",id:"example-scenarios",level:3},{value:"Resources",id:"resources",level:2}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"timing-and-synchronization"},"Timing and Synchronization"),(0,r.kt)("p",null,"This document describes Terragraph's architecture for time synchronization."),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Absolute time and phase synchronization are essential for the correct operation\nof a Terragraph network. The time division duplex (TDD) slot architecture of the\nphysical layer requires a timing precision less than the slot guard bands. In\naddition, absolute time is required at each sector for the derivation of the\nsuperframe number used for scheduling."),(0,r.kt)("p",null,"There are two possible approaches, explained further in the sections below:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"GPS:")," GPS receivers co-located with each node can be used to synchronize\nnetworks of arbitrary size."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},'Over-the-air sync (or "OTA sync"):'),' A single timing source can synchronize\ndownstream nodes over a limited number of hops using high-resolution TSF (or\n"HTSF") messages provided by Talyn firmware.')),(0,r.kt)("h3",{id:"gps"},"GPS"),(0,r.kt)("p",null,"The use of precise timing derived from a co-located GPS receiver meets timing\nrequirements, but it does present trade-offs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A node may not have clear sky visibility to at least 5 GPS satellites at all\ntimes of the day, and thus may fail to provide a 3D fix with timing using GPS."),(0,r.kt)("li",{parentName:"ul"},"The cost of a GPS receiver is high, which reduces the likelihood that client\nnodes (CNs) will have a GPS receiver.")),(0,r.kt)("p",null,"This document will describe the means to meet the network timing requirements\nthrough a design that minimizes the dependence on GPS visibility, while still\nmeeting the timing precision requirements. The design accomplishes this as\nfollows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Single satellite mode:")," By default, a GPS chip tries to estimate latitude,\nlongitude, altitude, and time. To solve for these 4 unknowns, it needs good\nvisibility of at least 4 satellites. Since Terragraph nodes are stationary\n(i.e. latitude, longitude, and altitude are already known), and time is the\nonly unknown, a single satellite is enough to estimate time. This design uses\na GPS chip which supports single satellite mode (a.k.a. time-only mode)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"GPS survey-in mode:")," Used to sanitize and refine the position assist, when\navailable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"RF sync:")," Fall back to air interface timestamps from a peer sector when GPS\nis unavailable. Terragraph supports time propagation over 1 hop for DNs, and\nover 2 hops for CNs. This means that a wireless link will stay up even if one\nof the peers has bad GPS signal reception.")),(0,r.kt)("a",{id:"timing-synchronization-ota-sync"}),(0,r.kt)("h3",{id:"ota-sync"},"OTA Sync"),(0,r.kt)("p",null,"OTA sync uses nanosecond Tx/Rx timestamps with roughly 6ns accuracy to\nsynchronize absolute time between Terragraph nodes. This mechanism involves a\ntwo-way timestamp exchange and compensates for estimated OTA propagation delay,\nmaking timing error independent of link distance."),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/ota_sync.png",width:"512"})),(0,r.kt)("p",null,"Sectors on downstream nodes are synchronized via a common 1pps signal going to\nall sectors on the node. Each second a SW-HTSF 1pps message is sent from the\nsector that is RF synced to all other sectors on the node. The common 1pps\nsignal does not need to be phase or frequency aligned to the timing reference;\nall phase and frequency correction is done in software so only a fairly reliable\nlocal clock is required."),(0,r.kt)("p",null,"Hardware requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Inter-sector sync requires a common 1pps signal to all basebands. The signal\ncan be generated by a GPS module, a dedicated clock chip ("system\nsynchronizer"), or a PPS output from the host processor if available (ex.\nPTP hardware clock).')),(0,r.kt)("p",null,"Trade-offs and limitations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Max hops:")," The default Terragraph frame structure tolerates up to 1\xb5s of\ntiming error, which will limit the possible number of wireless hops from the\ntiming source. Up to 5 hops of OTA sync has been verified on an OTA network,\nbut a larger number of hops should be feasible."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Y-street:"),' The current implementation does not support all deployment\nscenarios with Y-street topologies. Specifically, there is no mechanism for a\nY-street "root node" to decide which of two DN peers both in PPS sync should\nbe used as the source of timing. Additionally, at the Y-street root node time\ncannot flow in one leg and out the other: there is no mechanism in wireless\nfirmware to support this scenario, so the second leg will not ignite. There is\nno issue with time flowing from the root node to multiple DN peers.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mesh support:")," When a node is configured for SW-HTSF sync, the decision\nabout which sector to use as the timing source is made locally by the E2E\nminion without knowledge about the path the timing signal took. In order to\navoid timing loops in mesh networks (which would result in loss of\nsynchronization) any change in the timing path (e.g. due to an upstream link\ngoing down) requires a full link re-ignition. The current software\nimplementation accomplishes this through a configurable timer. This may limit\nthe size and complexity of mesh networks where GPS-free operation is practical\nor desired."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dynamic PPS timestamp source:")," Current software does not support\ndynamically changing the PPS timestamp source. Therefore, a node cannot\ndynamically switch between using a local GPS as the timing reference and OTA\nsync (e.g. when GPS loses sync). Additional changes in the E2E minion would be\nrequired to support this scenario, but no wireless firmware changes are\nrequired.")),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/ota_sync_example.svg",width:"600"})),(0,r.kt)("h2",{id:"timing-and-synchronization-1"},"Timing and Synchronization"),(0,r.kt)("p",null,"A node receives timing information in one of two ways:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Directly through an input timing source (e.g. GPS, PTP hardware clock)"),(0,r.kt)("li",{parentName:"ol"},"Indirectly through network messages")),(0,r.kt)("h3",{id:"synchronization-state-machine"},"Synchronization State Machine"),(0,r.kt)("p",null,"The state machine for timing synchronization in firmware comprises three states,\nwhich are as follows (in order of preference):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},'PPS sync (formerly "GPS sync"):'),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Entry condition:")," Valid time samples have been received for a few\nconsecutive seconds (typically 2 seconds)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Exit condition:")," Valid time samples have not been received for a few\nconsecutive seconds (typically 10 seconds)."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"RF sync:"),' Not in "PPS sync", but is reachable to a DN with "PPS sync" over\nwireless links (1-2 hops away, as explained above).',(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Entry condition:"),' Conditions for "PPS sync" have not been met, but a link\nexists to at least one other DN from which to derive timing.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Exit condition:"),' Conditions for "PPS sync" have not been met and no links\nto other DNs exist from which to derive timing.'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"No sync:")," Neither in PPS sync nor RF sync. This is the default state.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Entry condition:"),' Conditions for "PPS sync" or "RF sync" are not met.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Exit condition:"),' Condition for "PPS sync" or "RF sync" are met.')))),(0,r.kt)("h3",{id:"time-sample-validity"},"Time Sample Validity"),(0,r.kt)("p",null,"Time samples are collected each second. The components of the time sample and\nits validity criteria and thresholds are defined as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The new time must be +1 when compared to the previous sample."),(0,r.kt)("li",{parentName:"ul"},"The TSF value must be greater than the TSF value latched at the previous 1pps\nstrobe by 1,000,000 \xb120 \xb5s.")),(0,r.kt)("p",null,"Other software layers may contain additional validity checks. For example, the\nu-blox driver used on Rev5 enforced the following conditions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The internal oscillator offset and uncertainty reported by GPS must be within\n\xb1500 ppb."),(0,r.kt)("li",{parentName:"ul"},"The 1pps strobe time offset and uncertainty reported by GPS must be within\n\xb1500 ns."),(0,r.kt)("li",{parentName:"ul"},"There must be no software errors reported pertaining to the GPS, communication\nwith the GPS, or failure of the 1pps latch. Examples include I2C communication\nerrors between the GPS and CPU, or a stuck microcode for the 1pps latch.")),(0,r.kt)("h3",{id:"timing-constraints"},"Timing Constraints"),(0,r.kt)("p",null,"In order to ensure the synchronization of time slots for all sectors, the time\nto perform certain operations in a sector must be constrained. A guard time\nbetween slots provides the protection necessary to provide sufficient\nsynchronization. Additionally, a delayed Tx slot start time is needed for\nsuccessful reception of the first packet in the Tx slot."),(0,r.kt)("p",null,"The following diagram shows a synchronization timing slot, including a guard\ntime (8\xb5s) and delayed start time for Tx slot (2\xb5s)."),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/slot_timing.svg",width:"720"})),(0,r.kt)("p",null,"Terragraph timing slots have the following timing error constraints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"T_pps:")," Worst case is +/- 0.5\xb5s for a 1\xb5s error. For example, this may\nhappen due to poor GPS signal reception. Typically, this is 0.1\xb5s."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"T_stamping, T_quantization:")," Worst case is 1\xb5s."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"T_Propagation:")," 1\xb5s for a 300 meter link."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"T_slot_switch:")," Worst case is 5.1\xb5s for ",(0,r.kt)("strong",{parentName:"li"},"rx_slot")," end to ",(0,r.kt)("strong",{parentName:"li"},"rx_slot"),"\nstart. This includes hardware processing time for the RF and PHY/MAC layers.")),(0,r.kt)("p",null,"Terragraph timing slot subframes have the following timing values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Guard time of 8\xb5s = (T_pps or T_Propagation) + T_quantization + T_Propagation + T_slot_switch\nDelayed Tx slot start time of 2\xb5s = (T_pps or T_Propagation) + T_quantization\n")),(0,r.kt)("h3",{id:"timing-correction"},"Timing Correction"),(0,r.kt)("p",null,"The Timing Synchronization Function (TSF) is a 64-bit microsecond counter that\nis used as a measure of time for all MAC operations. The software allows and\ncorrects finite drifts in the frequency."),(0,r.kt)("p",null,"More specifically, there are two TSF values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},'Hardware TSF ("HW TSF"):')," The raw TSF values captured by the hardware\nfree-running TSF counter when events occur (ex. PPS, Tx/Rx). The HW TSF timer\ngets updated only once during the initial setup of the MAC frame structure."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},'Software TSF ("SW TSF"):')," The actual TSF time, i.e. HW TSF + TSF offset\nmaintained by software. This is the common Terragraph clock time at any\ninstant. Terragraph sectors achieve PPS/RF sync by tuning the TSF offset\nvalues maintained in software.")),(0,r.kt)("h4",{id:"pps-sync-state"},"PPS Sync State"),(0,r.kt)("p",null,'In the "PPS sync" state, the Terragraph clock is precisely disciplined by an\ninput timing source (e.g. GPS at typically 5ppb). Common sources of error\ninclude PLL (phase-locked loop) least counts and GPS oscillator\noffsets/uncertainties. The software uses a 1pps strobe to correct any drifts,\nand applies the correction once per second at every 1pps strobe. The successive\n1pps strobes should be 1 second apart. Any difference is applied as a timing\ncorrection each second. The maximum correction applied is 20\xb5s per second,\nallowing correction of timing drifts within 20ppm.'),(0,r.kt)("h4",{id:"rf-sync-state"},"RF Sync State"),(0,r.kt)("p",null,'In the "RF sync" state, the software relies on a peer station\'s timing. Peer\nstations exchange management messages over the wireless link every 25ms. These\nmessages contain a transmit timestamp from the peer station, which must match\nthe local receive timestamp. Any difference between the local timestamp and the\ntimestamp in the frame gets applied as a timing correction every 25ms. The\nmaximum correction applied is 1\xb5s per 25ms. This allows correction of timing\ndrifts within 40ppm.'),(0,r.kt)("h2",{id:"ignition-and-link-management"},"Ignition and Link Management"),(0,r.kt)("p",null,'When a node is in the "RF sync" state, timing is derived from a peer node.\nHowever, timing errors can occur and accumulate at each hop, which degrades\ntiming. Terragraph places a limit on the number of hops allowed from a timing\nsource and controls the accumulation of timing errors by implementing the\nfollowing constraints:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'A DN may only ignite another DN if it is in the "PPS sync" state.'),(0,r.kt)("li",{parentName:"ul"},'A DN may only ignite a CN if it is in the "PPS sync" or "RF sync" state.'),(0,r.kt)("li",{parentName:"ul"},'A DN in the "RF sync" state will remove a link to a peer DN if the peer is not\nin the "PPS sync" state.')),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"sync state indicator")," (SSI) provides this information as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When a node gets its timing from network messages, the SSI will be the\nnumber of hops between the local node and the node serving as the timing\nsource."),(0,r.kt)("li",{parentName:"ul"},"When a node gets its timing directly from an input timing source, the SSI will\nbe zero."),(0,r.kt)("li",{parentName:"ul"},'When a node is in the "no sync" state, the SSI will be 255.')),(0,r.kt)("p",null,"The table below shows the link management actions for each sync state. In the\ncurrent Terragraph implementation, X = 1."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Sync State"),(0,r.kt)("th",{parentName:"tr",align:null},"Initiate Link to Peer DN"),(0,r.kt)("th",{parentName:"tr",align:null},"Initiate Link to Peer CN"),(0,r.kt)("th",{parentName:"tr",align:null},"Accept Link Initiation from Peer DN"),(0,r.kt)("th",{parentName:"tr",align:null},"Delete Peer DN Link"),(0,r.kt)("th",{parentName:"tr",align:null},"Delete Peer CN Link"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PPS Sync"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"No")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RF Sync ","[local SSI < X]"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"No")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RF Sync ","[local SSI >= X]"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes if peer SSI >= X"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No Sync"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"n/a"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes")))),(0,r.kt)("h2",{id:"e2e-controller-and-gps-survey-in"},"E2E Controller and GPS Survey-In"),(0,r.kt)("p",null,'Where applicable, the configuration of the GPS receiver on each DN is handled by\nthe E2E controller. The E2E controller enables position-assisted GPS and\nminimizes the need for user input. Since the DN is immobile, it uses the\n"survey-in" feature to determine its own position. When a node is in "survey-in"\nmode, it surveys the sky for satellites from which to get its geographic\ncoordinates (longitude and latitude). The node will remain in "survey-in" mode\nuntil:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It gets its GPS coordinates from a satellite."),(0,r.kt)("li",{parentName:"ul"},'"Survey-in" fails.'),(0,r.kt)("li",{parentName:"ul"},"A user manually inputs the GPS coordinates.")),(0,r.kt)("p",null,'GPS coordinates are persisted by the E2E controller. When the E2E controller\ndoes not have GPS coordinates recorded for any node, it gets them from\n"survey-in" at the time of ignition. "Survey-in" fails only if a node never sees\nmore than 4 satellites. Such a node cannot be an initiator, but can still be\nignited as a responder. The user does not need to provide GPS coordinates except\nin cases where "survey-in" fails, and any GPS coordinates entered manually must\nhave an accuracy of better than 50 meters.'),(0,r.kt)("p",null,"For supported GPS modules, the E2E controller automatically configures single\nsatellite mode using its recorded GPS coordinates for each node."),(0,r.kt)("p",null,'Sectors must self-assert on GPS timing uncertainty greater than 0.5\xb5s and revert\nto the "RF sync" state.'),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"This section describes the timing architecture on Terragraph reference\nplatforms, and how to support additional GPS modules."),(0,r.kt)("h3",{id:"terragraph-hardware"},"Terragraph Hardware"),(0,r.kt)("p",null,"Details from different Terragraph hardware revisions are summarized below."),(0,r.kt)("h4",{id:"rev5-hardware"},"Rev5 Hardware"),(0,r.kt)("p",null,"Rev5 hardware uses the u-blox LEA-M8F GPS module. The module is connected over\nI2C, and NMEA message handling is done via an in-kernel driver (see\n",(0,r.kt)("inlineCode",{parentName:"p"},"recipes-radio/ublox-mod/kernel-module-ublox_0.1.bb"),"). Timestamp messages are\nforwarded from the u-blox driver to the Terragraph driver, which sends them to\nthe wireless firmware. Single satellite mode is achieved using the u-blox\n",(0,r.kt)("inlineCode",{parentName:"p"},"UBX-CFG-TMODE2"),' ("Time Mode") command.'),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/gps_rev5.svg",width:"512"})),(0,r.kt)("p",null,"Note that per u-blox specification, the GPS module is calibrated for a maximum\ndrift of 100ppb after 24 hours of holdover (a mode of operation where GPS timing\nis temporarily maintained even after synchronization with GPS satellites is\nlost). This implies that the GPS holdover state of u-blox in the first few\nseconds after loss of GPS lock should be near precise."),(0,r.kt)("h4",{id:"puma-hardware"},"Puma Hardware"),(0,r.kt)("p",null,"Puma hardware uses the Telit SL869-T GPS module and TG2520SMN crystal. The\nmodule is connected over UART, and NMEA message handling is done via ",(0,r.kt)("a",{parentName:"p",href:"https://gpsd.gitlab.io/gpsd/index.html"},"gpsd"),".\nTerragraph's ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," connects to gpsd to receive timestamps, then forwards\nthem over Netlink (as ",(0,r.kt)("inlineCode",{parentName:"p"},"TGD_NLSDN_CMD_SET_GPS_TIME"),") to the Terragraph driver to\nsend to the wireless firmware. Single satellite mode is achieved using the Telit\n",(0,r.kt)("inlineCode",{parentName:"p"},"$PSTMENABLEPOSITIONHOLD"),' ("Position Hold") command.'),(0,r.kt)("p",null,"Some functionality depends on a custom PPS source (default ",(0,r.kt)("inlineCode",{parentName:"p"},"/dev/pps1"),") which\nasserts on ",(0,r.kt)("inlineCode",{parentName:"p"},"ETS")," interrupts from QorIQ's PTP clock driver:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"gpsd handles the asserts from the PPS source. When ",(0,r.kt)("inlineCode",{parentName:"li"},"driver-if")," receives a\ncorresponding PPS message from gpsd, it forwards the attached timestamp to\nthe wireless firmware."),(0,r.kt)("li",{parentName:"ul"},"System time is synchronized using a combination of PPS signals and GPS\nmessages (default ",(0,r.kt)("inlineCode",{parentName:"li"},"/dev/ttyS1"),"). When enabled, ",(0,r.kt)("inlineCode",{parentName:"li"},"chronyd")," is configured to\nsample GPS and PPS messages using the SHM and SOCK mechanisms via gpsd.")),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/gps_puma.svg",width:"512"})),(0,r.kt)("a",{id:"timing-synchronization-puma-mbh-hardware"}),(0,r.kt)("h4",{id:"puma-mbh-hardware"},"Puma MBH Hardware"),(0,r.kt)("p",null,'Specialized "Puma MBH" (Mobile Backhaul) builds include additional hardware to\nsupport 1588v2 (PTP) and SyncE transport for time (phase) and frequency\nsynchronization. Refer to ',(0,r.kt)("a",{parentName:"p",href:"/docs/developer/PTP_SyncE"},"PTP & SyncE")," for more details about\nthese protocols and implementations."),(0,r.kt)("p",null,"The additional hardware includes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Microsemi ZL30795 system synchronizer (with SyncE DPLL), controlled by the\n",(0,r.kt)("inlineCode",{parentName:"li"},"zl3079x")," driver (see\n",(0,r.kt)("inlineCode",{parentName:"li"},"recipes-radio/microsemi-dpll/kernel-module-zl3079x_0.1.bb"),")."),(0,r.kt)("li",{parentName:"ul"},"Microsemi VSC8254 dual 10G SFP+ PHY, controlled by the ",(0,r.kt)("inlineCode",{parentName:"li"},"malibu_char"),"\napplication (see ",(0,r.kt)("inlineCode",{parentName:"li"},"recipes-utils/vsc8254phy/vsc8254.bb"),") built on the\nuser-space ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/microchip-ung/mesa"},"MESA")," library.")),(0,r.kt)("p",null,"Puma MBH offers PTP Transparent Clock (PTP-TC) Class A/B functionality with or\nwithout GPS, and implements timestamping via one-step correction field update in\neither of two layers:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NPU")," (NXP LS1048A) with ~20ns accuracy, implemented on the host in the\n",(0,r.kt)("inlineCode",{parentName:"li"},"ptptc")," VPP plugin (see ",(0,r.kt)("inlineCode",{parentName:"li"},"recipes-facebook/vpp-ptptc/vpp-ptptc_0.1.bb"),")."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"10G PHY")," (Microsemi VSC8254) with ~1ns accuracy, statically configured\nthrough ",(0,r.kt)("inlineCode",{parentName:"li"},"malibu_char"),".")),(0,r.kt)("p",null,"The SyncE PLL loop filter is implemented in the ",(0,r.kt)("inlineCode",{parentName:"p"},"zl3079x")," driver as a PI\ncontroller, and is driven by phase error measurements contained in HTSF messages\nfrom Talyn firmware every BWGD (25.6ms) via the Terragraph driver. Support for\nthe Ethernet Synchronization Messaging Channel (ESMC) protocol (ITU-T G.8264) is\nhandled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"esmc")," VPP plugin (see\n",(0,r.kt)("inlineCode",{parentName:"p"},"recipes-facebook/vpp-esmc/vpp-esmc_1.0.bb"),")."),(0,r.kt)("p",null,"The E2E minion (",(0,r.kt)("inlineCode",{parentName:"p"},"PTPClockHelper")," class) synchronizes clocks on the NPU and/or\n10G PHY at each 1pps strobe as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NPU")," via direct DPAA2 register reads/writes to synchronize the NXP PTP\nhardware clock."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"10G PHY")," via a custom datagram socket protocol in ",(0,r.kt)("inlineCode",{parentName:"li"},"malibu_char")," to\nsynchronize the VSC LTC (local time counter) clock.")),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/puma_mbh_arch.svg",width:"600"})),(0,r.kt)("h3",{id:"gps-porting-guide"},"GPS Porting Guide"),(0,r.kt)("p",null,"Requirements and instructions for supporting other GPS modules are described\nbelow."),(0,r.kt)("h4",{id:"constraints"},"Constraints"),(0,r.kt)("p",null,"Terragraph wireless firmware has the following hard requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The firmware must receive a periodic timestamp message (",(0,r.kt)("inlineCode",{parentName:"li"},"TG_SB_GPS_TIME"),'\nioctl) shortly after every 1pps strobe to remain in "GPS sync", with a maximum\ngap of roughly 200ms.'),(0,r.kt)("li",{parentName:"ul"},"The duty cycle for the PPS pulse should be less than 50%. More specifically, a\npulse width of roughly 200ms works well, but a width of 500ms results in\nout-of-sync TSF values and subsequent ignition failures.")),(0,r.kt)("h4",{id:"code-changes"},"Code Changes"),(0,r.kt)("p",null,"It is recommended to use the gpsd architecture when possible; any GPS module\nthat can output NMEA0183-compliant messages will work with gpsd. This requires\nfairly limited changes in the following places:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node configuration:")," Add default hardware-specific node configuration\nvalues for all ",(0,r.kt)("inlineCode",{parentName:"li"},"envParams.GPSD_*")," entries. This defines the NMEA/PPS serial\nports, baud rate, NMEA time offset calibration factor, etc."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Initial GPS configuration:")," Send any commands needed to configure the GPS\nmodule before gpsd starts (e.g. setting pulse width, configuring NMEA output\nmessages). This is done as part of the gpsd SV script in\n",(0,r.kt)("inlineCode",{parentName:"li"},"recipes-support/gpsd/files/sv/gpsd.run"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Single satellite mode:")," If the GPS module supports single satellite mode\noperation, send the command to configure it via ",(0,r.kt)("inlineCode",{parentName:"li"},"driver-if"),":\n",(0,r.kt)("inlineCode",{parentName:"li"},"BaseDriverIf::sendLocationToGpsBase()")," in\n",(0,r.kt)("inlineCode",{parentName:"li"},"src/terragraph-e2e/e2e/driver-if/BaseDriverIf.cpp"),". For instance, this method\nis triggered when the E2E controller sends down the node's precise location."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Non-standard NMEA0183 data:")," If the GPS module outputs non-standard data in\nany non-proprietary NMEA0183 sentence, corrections should be applied (if\npossible) in ",(0,r.kt)("inlineCode",{parentName:"li"},"driver-if")," before any further processing takes place:\n",(0,r.kt)("inlineCode",{parentName:"li"},"GpsdClient::preprocessData()")," in\n",(0,r.kt)("inlineCode",{parentName:"li"},"src/terragraph-e2e/e2e/driver-if/GpsdClient.cpp"),". For example, a GPS module\nmay report WGS84 altitude where MSL altitude is expected, which would\ninvalidate some calculations within gpsd.")),(0,r.kt)("p",null,"If the GPS module is not compatible with gpsd, an alternative is to write a\nkernel module implementing the Terragraph driver's GPS interface, found in\n",(0,r.kt)("inlineCode",{parentName:"p"},"recipes-radio/wireless-mod/files/nl-driver-if-hdr/fb_tg_gps_driver_if.h"),"."),(0,r.kt)("h2",{id:"gps-stats"},"GPS Stats"),(0,r.kt)("p",null,"Stats about GPS state are exported from wireless firmware, the u-blox driver,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," (when connected to gpsd). These are published by ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," on\na ZMQ port (see ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer/Stats_Events_Logs"},"Stats, Events, Logs")," for details)."),(0,r.kt)("h3",{id:"firmware-stats"},"Firmware Stats"),(0,r.kt)("p",null,"GPS stats from wireless firmware are shown in the table below."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Key"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.driverDelay")),(0,r.kt)("td",{parentName:"tr",align:null},"Driver ioctl delay from PPS tsf boundary (in microseconds)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.maxDriverDelay")),(0,r.kt)("td",{parentName:"tr",align:null},'Max of "driverDelay"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.numPpsErr")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of PPS tsf read errors")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.numTimelineErr")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of errors due to firmware/driver taking more time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.numMissedSec")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of times driver did not send GPS time (derived from tsf, and can increase by many counts per second)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.ppsJitter")),(0,r.kt)("td",{parentName:"tr",align:null},"Jitter for the last PPS tsf (in microseconds), only recording ",(0,r.kt)("em",{parentName:"td"},"valid")," samples (i.e. PPS jitter <= 25us) used for GPS drift correction")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.maxPpsJitter")),(0,r.kt)("td",{parentName:"tr",align:null},'Max of "ppsJitter", but counting ',(0,r.kt)("em",{parentName:"td"},"all")," received samples (including samples with high PPS jitter)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.tsfDrift")),(0,r.kt)("td",{parentName:"tr",align:null},"Cumulative drift in tsf")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.ppsHwTsf")),(0,r.kt)("td",{parentName:"tr",align:null},"HW TSF at last PPS")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.ppsHwTsfNs")),(0,r.kt)("td",{parentName:"tr",align:null},"HW TSF at last PPS ns portion")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.ppsSwTsf")),(0,r.kt)("td",{parentName:"tr",align:null},"SW TSF at last PPS")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.gps.ppsSwTsfNs")),(0,r.kt)("td",{parentName:"tr",align:null},"SW TSF at last PPS ns portion")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.syncModeGps")),(0,r.kt)("td",{parentName:"tr",align:null},'1 if tsf is in "GPS sync" state, otherwise 0')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.syncModeRf")),(0,r.kt)("td",{parentName:"tr",align:null},'1 if tsf is in "RF sync" state, otherwise 0')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.numRfFix")),(0,r.kt)("td",{parentName:"tr",align:null},'Number of times tsf offset fixed on "RF sync"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.numGpsFix")),(0,r.kt)("td",{parentName:"tr",align:null},'Number of times tsf offset fixed on "GPS sync"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.rfDrift")),(0,r.kt)("td",{parentName:"tr",align:null},"Largest value of tsf drift over current stats interval with regard to the RF link")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.sumRfFix")),(0,r.kt)("td",{parentName:"tr",align:null},'Sum of tsf fixes for "RF sync"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.sumGpsFix")),(0,r.kt)("td",{parentName:"tr",align:null},'Sum of tsf fixes for "GPS sync"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.offsetL")),(0,r.kt)("td",{parentName:"tr",align:null},"Low word of current offset (",(0,r.kt)("inlineCode",{parentName:"td"},"sw_tsf - hw_tsf"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.offsetH")),(0,r.kt)("td",{parentName:"tr",align:null},"High word of current offset (",(0,r.kt)("inlineCode",{parentName:"td"},"sw_tsf - hw_tsf"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgf.MAC.tsf.driftPerWin")),(0,r.kt)("td",{parentName:"tr",align:null},"Average drift per window (e.g. per 10s)")))),(0,r.kt)("h3",{id:"driver-stats"},"Driver Stats"),(0,r.kt)("p",null,"A subset of GPS stats from the u-blox driver and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," are shown in the\ntable below. These sources export a similar, but not identical, set of keys.\nu-blox driver keys are constructed in ",(0,r.kt)("inlineCode",{parentName:"p"},"DriverIfUtil::processGpsStatus()"),", and\ngpsd keys in ",(0,r.kt)("inlineCode",{parentName:"p"},"GpsdClient::getStats()"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Key"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.latitude")),(0,r.kt)("td",{parentName:"tr",align:null},"Latitude (decimal) in 1e7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.longitude")),(0,r.kt)("td",{parentName:"tr",align:null},"Longitude (decimal) in 1e7")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.heightMsl")),(0,r.kt)("td",{parentName:"tr",align:null},"Height above mean sea level in millimeters")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.heightEllipsoid")),(0,r.kt)("td",{parentName:"tr",align:null},"Height above ellipsoid in millimeters")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.fixNumSat")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of satellites used in Nav Solution (from NAV-PVT)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.fixType")),(0,r.kt)("td",{parentName:"tr",align:null},"GNSS fix type: 0=no fix, 3=3D fix, 5=time-only fix (from NAV-PVT) for u-blox driver; or 0=unknown, 1=none, 2=2D fix, 3=3D fix for gpsd")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.gnssTmOfset")),(0,r.kt)("td",{parentName:"tr",align:null},"Time offset between the preceding pulse and GNSS top-of-second in nanoseconds (from TIM-TOS)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.gnssTmUncert")),(0,r.kt)("td",{parentName:"tr",align:null},"Uncertainty of GNSS offset in nanoseconds (from TIM-TOS)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.intOscOfset")),(0,r.kt)("td",{parentName:"tr",align:null},"Internal oscillator frequency offset in ppb (from TIM-TOS)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.intOscUncert")),(0,r.kt)("td",{parentName:"tr",align:null},"Internal oscillator frequency uncertainty in ppb (from TIM-TOS)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.discipSrc")),(0,r.kt)("td",{parentName:"tr",align:null},"Disciplining source identifier: 0=internal oscillator, 1=GNSS, 2..5=other (from TIM-TOS)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.timTosFlag")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitmap with information about locked pulse, leap second, RAIM, etc. (from TIM-TOS)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.n.snr")),(0,r.kt)("td",{parentName:"tr",align:null},"Carrier-to-Noise Ratio (signal strength) in dBHz (from NAV-SVINFO)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.n.quality")),(0,r.kt)("td",{parentName:"tr",align:null},"Signal quality indicator: 0=no signal, 1=searching signal, 2=signal acquired, 3=signal detected but unusable, 4=code locked and time synchronized, 5..7=code and carrier locked and time synchronized (from NAV-SVINFO)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.n.flag")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitmap for health, orbit info, etc. (from NAV-SVINFO)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.n.elevation")),(0,r.kt)("td",{parentName:"tr",align:null},"Elevation in integer degrees (from NAV-SVINFO)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.dataLenError")),(0,r.kt)("td",{parentName:"tr",align:null},"Length of invalid ",(0,r.kt)("inlineCode",{parentName:"td"},"t_gps_stat")," buffer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.svDataLenError")),(0,r.kt)("td",{parentName:"tr",align:null},"Length of invalid ",(0,r.kt)("inlineCode",{parentName:"td"},"t_gps_space_veh_info")," buffer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.unixTs")),(0,r.kt)("td",{parentName:"tr",align:null},"The UNIX timestamp associated with this GPS sample")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tgd.gpsStat.MAC.numTsSent")),(0,r.kt)("td",{parentName:"tr",align:null},"Number of timestamps sent to firmware from ",(0,r.kt)("inlineCode",{parentName:"td"},"driver-if"))))),(0,r.kt)("h2",{id:"node-configuration"},"Node Configuration"),(0,r.kt)("p",null,"This section lists the node configuration fields related to the features\ndescribed above. For more detailed specifications, refer to the config metadata\nfile."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Category"),(0,r.kt)("th",{parentName:"tr",align:null},"Field(s)"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PPS Sync"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PPS_TIMESTAMP_SOURCE")),(0,r.kt)("td",{parentName:"tr",align:null},"The time source for 1pps timestamps sent to wireless firmware (e.g. GPS, PTP, HTSF).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.HTSF_MAX_LOOP_SIZE"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.HTSF_SRC_MAC")),(0,r.kt)("td",{parentName:"tr",align:null},"Additional parameters for networks using OTA sync (i.e. HTSF sync).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"radioParamsBase.fwParams.forceGpsDisable")),(0,r.kt)("td",{parentName:"tr",align:null},'Disable synchronization checks in wireless firmware, and thus allow association in the "RF sync" state on both ends of the link. This will only work over 1 hop for DNs, and over 2 hops for CNs. This ',(0,r.kt)("em",{parentName:"td"},"cannot")," be used for DN-to-DN links using OTA sync (i.e. HTSF sync).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"radioParamsBase.fwParams.htsfSyncEnable")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable HTSF sync.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GPS"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_ENABLED")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable the gpsd daemon and timestamp forwarding via ",(0,r.kt)("inlineCode",{parentName:"td"},"driver-if"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_GPS_MODULE")),(0,r.kt)("td",{parentName:"tr",align:null},"The identifier (e.g. name/vendor) of the GPS module, which may enable module-specific functionality.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_DEVICE"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_BAUD_RATE")),(0,r.kt)("td",{parentName:"tr",align:null},"GPS system parameters.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_POSITION_HOLD_ENABLED")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable single-satellite mode opration on supported GPS modules.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_PPS_DEVICE"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"envParams.GPSD_NMEA_TIME_OFFSET")),(0,r.kt)("td",{parentName:"tr",align:null},"Synchronize system time to GPS/PPS via gpsd and chronyd.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PTP"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_TIMER_SOURCE")),(0,r.kt)("td",{parentName:"tr",align:null},"The 1pps timestamp source used to synchronize the NXP PTP hardware clock and/or VSC LTC clock.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_DEVICE")),(0,r.kt)("td",{parentName:"tr",align:null},"Synchronize the NXP PTP hardware clock via the given device.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_VPP_INTERFACE"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_VPP_OFFSET_NS"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_VPP_NXP_PORT")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable PTP-TC timestamping via NXP NPU in the ",(0,r.kt)("inlineCode",{parentName:"td"},"ptptc")," VPP plugin.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_VSC_CTRL_SOCKET"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_VSC_PORT")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable PTP-TC timestamping via VSC 10G PHY, as well as LTC clock synchronization.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SyncE"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.ESMC_ENABLED"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"timingParams.PTP_VSC_PORT")),(0,r.kt)("td",{parentName:"tr",align:null},"Configure the given VSC 10G PHY port for SyncE, and enable the ",(0,r.kt)("inlineCode",{parentName:"td"},"esmc")," VPP plugin to generate and handle ESMC protocol frames on the corresponding interface (port 0 = ",(0,r.kt)("inlineCode",{parentName:"td"},"TenGigabitEthernet1"),", port 1 = ",(0,r.kt)("inlineCode",{parentName:"td"},"TenGigabitEthernet0"),").")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"radioParamsBase.fwParams.htsfMsgInterval")),(0,r.kt)("td",{parentName:"tr",align:null},"Enable per-BWGD HTSF messages (",(0,r.kt)("inlineCode",{parentName:"td"},"TG_NB_HTSF_INFO"),") containing the timing error between nodes in nanoseconds, which is computed by wireless firmware every keepalive. For SyncE operation, set this to 1 in order to pass the timing error signal to the SyncE PLL every BWGD. Otherwise, set this to 0 (default) to disable the messages and avoid unnecessary overhead for systems that do not support SyncE.")))),(0,r.kt)("h2",{id:"ota-sync-deployment-notes"},"OTA Sync Deployment Notes"),(0,r.kt)("p",null,"Instructions and considerations for deploying GPS-free Terragraph networks are\ngiven in the sections below."),(0,r.kt)("h3",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,"A network using OTA sync should apply the following node configuration:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Timing source node(s):")," Set ",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.PPS_TIMESTAMP_SOURCE")," to ",(0,r.kt)("inlineCode",{parentName:"li"},'"GPS"'),"\n(co-located GPS receiver) or ",(0,r.kt)("inlineCode",{parentName:"li"},'"PTP"')," (free-running PTP hardware clock), which\ndetermines the source of the 1pps timestamps sent to wireless firmware. For\nexample, the timing source node can be a single POP node; when using multiple\nnodes, their clocks must be externally synchronized (e.g. via GPS or PTP)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Other nodes:")," Set ",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.PPS_TIMESTAMP_SOURCE")," to ",(0,r.kt)("inlineCode",{parentName:"li"},'"SW_HTSF"')," so\nthat they derive timing from upstream HTSF messages."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"All nodes:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"envParams.GPSD_ENABLED")," to ",(0,r.kt)("inlineCode",{parentName:"li"},'"0"')," to disable gpsd features (unless\nneeded on a timing source node)."),(0,r.kt)("li",{parentName:"ul"},"Set ",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.HTSF_MAX_LOOP_SIZE")," to the largest possible timing loop\nsize (mesh networks only).")))),(0,r.kt)("h3",{id:"example-scenarios"},"Example Scenarios"),(0,r.kt)("p",null,"The following examples highlight several topologies where OTA sync is fully,\npartially, or not supported."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Topology 1:")," This topology is not a mesh topology and does not contain\nY-streets, so any DN can be configured as the timing source node. Multiple nodes\ncould be configured as timing source nodes if each node uses the same external\nreference, such as GPS. However, nodes configured as timing source nodes cannot\ndynamically switch to OTA sync without a configuration change."),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/ota_sync_topology_1.svg",width:"900"}),(0,r.kt)("br",null),(0,r.kt)("em",null,"Topology 1")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Topology 2:")," This topology contains a Y-street, so not all scenarios are\nsupported."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If DN1 is configured as the timing reference node then the topology is\nsupported."),(0,r.kt)("li",{parentName:"ul"},"However, DN4 cannot be the timing reference node because depending on the\norder in which links are ignited, DN1 could become a Y-street root node with\nmultiple DN peers in PPS sync, which is not supported.")),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/ota_sync_topology_2.svg",width:"300"}),(0,r.kt)("br",null),(0,r.kt)("em",null,"Topology 2")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Topology 3:")," This topology contains a Y-street, so not all scenarios are\nsupported."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If DN2 is configured as the timing reference node then the topology is\nsupported."),(0,r.kt)("li",{parentName:"ul"},"If DN1 is configured as the timing reference the DN2-DN3 link will not ignite\nbecause time cannot flow in one leg of a Y-street root node and out the other\nleg, so this scenario is not supported.")),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/ota_sync_topology_3.svg",width:"450"}),(0,r.kt)("br",null),(0,r.kt)("em",null,"Topology 3")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Topology 4:")," This figure-8 topology does not contain any Y-streets so in\ngeneral is supported with any node configured as the timing reference node.\nHowever, there are many possible ways for timing to flow, so to avoid timing\nloops any link going down may result in a complete re-ignition of other links in\norder to re-arrange the timing path."),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/ota_sync_topology_4.svg",width:"512"}),(0,r.kt)("br",null),(0,r.kt)("em",null,"Topology 4")),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://gpsd.gitlab.io/gpsd/index.html"},"gpsd")," - GPS service daemon"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/microchip-ung/mesa"},"MESA")," - Microchip Ethernet Switch API")))}m.isMDXComponent=!0}}]);