"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7534],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),h=d(n),u=i,c=h["".concat(s,".").concat(u)]||h[u]||p[u]||r;return n?a.createElement(c,l(l({ref:t},m),{},{components:n})):a.createElement(c,l({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var d=2;d<r;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6565:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={},l="PHY Algorithms",o={unversionedId:"developer/PHY_Algorithms",id:"developer/PHY_Algorithms",title:"PHY Algorithms",description:"This document describes the configuration of some physical (PHY) layer",source:"@site/../docs/developer/PHY_Algorithms.md",sourceDirName:"developer",slug:"/developer/PHY_Algorithms",permalink:"/docs/developer/PHY_Algorithms",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/PHY_Algorithms.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"MAC & PHY Specification",permalink:"/docs/developer/MAC_PHY_Specification"},next:{title:"Firmware Stats",permalink:"/docs/developer/Firmware_Stats"}},s={},d=[{value:"Maximum AGC &amp; Minimum RSSI",id:"maximum-agc--minimum-rssi",level:2},{value:"Algorithm Description",id:"algorithm-description",level:3},{value:"Calculating Gains",id:"calculating-gains",level:3},{value:"Details",id:"details",level:4},{value:"P2MP",id:"p2mp",level:3},{value:"RF Gain Hi/Lo",id:"rf-gain-hilo",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Dynamic AGC Configuration",id:"dynamic-agc-configuration",level:3},{value:"Using FW_CONFIG_REQ",id:"using-fw_config_req",level:4},{value:"Using PhyAgcParams",id:"using-phyagcparams",level:4},{value:"Link Adaptation and Transmit Power Control (LA/TPC)",id:"link-adaptation-and-transmit-power-control-latpc",level:2},{value:"Traffic-Driven Mode",id:"traffic-driven-mode",level:3},{value:"No-Traffic Mode",id:"no-traffic-mode",level:3},{value:"Core Algorithm",id:"core-algorithm",level:3},{value:"LA/TPC Configuration",id:"latpc-configuration",level:3},{value:"BLER to PER",id:"bler-to-per",level:3},{value:"Setting Maximum Transmit Power Per MCS",id:"setting-maximum-transmit-power-per-mcs",level:3},{value:"Data Traffic vs. No Data Traffic",id:"data-traffic-vs-no-data-traffic",level:3},{value:"PER Target",id:"per-target",level:3},{value:"100% PER Condition",id:"100-per-condition",level:3},{value:"Fast Link Impairment Detection",id:"fast-link-impairment-detection",level:2},{value:"Conditions for Link Impairment",id:"conditions-for-link-impairment",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:4},{value:"Debouncing",id:"debouncing",level:3},{value:"Monitoring Link Impairment",id:"monitoring-link-impairment",level:3}],m={toc:d};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"phy-algorithms"},"PHY Algorithms"),(0,i.kt)("p",null,"This document describes the configuration of some physical (PHY) layer\nalgorithms."),(0,i.kt)("h2",{id:"maximum-agc--minimum-rssi"},"Maximum AGC & Minimum RSSI"),(0,i.kt)("p",null,"To limit early-weak interference, Terragraph includes a feature to either limit\nthe maximum automatic gain control (AGC) gain or the minimum received signal\nstrength indicator (RSSI). An interfering signal that is below the minimum RSSI\nthreshold or requires a gain above the maximum AGC limit will not be detected.\nAn algorithm running in the firmware tracks the gain and RSSI of the desired\nsignal, and limits the maximum AGC and minimum RSSI at some margin from the\ndesired signal."),(0,i.kt)("p",null,"The AGC has an IF and RF gain component. The overall gain (in dB) is calculated\nas follows, using configurable vendor-specific coefficients ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," (default 1.0)\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," (default 7.0):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"gain = a*IF + b*RF\n")),(0,i.kt)("p",null,"For example, if the AGC of the desired signal is ",(0,i.kt)("inlineCode",{parentName:"p"},"IF = 3, RF = 2")," and the\ncorresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"RSSI = -40dBm"),", the maximum AGC could be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"IF = 4, RF = 3"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"minRSSI = -48dBm"),". Any signal requiring a gain greater than\n",(0,i.kt)("inlineCode",{parentName:"p"},"IF = 4, RF = 3")," or having ",(0,i.kt)("inlineCode",{parentName:"p"},"RSSI < -48dBm")," would not be detected."),(0,i.kt)("h3",{id:"algorithm-description"},"Algorithm Description"),(0,i.kt)("p",null,"The hardware provides the measured RSSI value, and optionally the IF and RF\ngains and the ",(0,i.kt)("em",{parentName:"p"},"raw")," analog-to-digital converter (ADC) RSSI, i.e. the RSSI\nmeasured after gains are applied. The algorithm can either calculate a relative\nRSSI based on the gains and raw RSSI (if ",(0,i.kt)("inlineCode",{parentName:"p"},"useMinRssi")," is not set) or use the\nmeasured RSSI (if ",(0,i.kt)("inlineCode",{parentName:"p"},"useMinRssi")," is set)."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"useMinRssi")," is not set, the relative RSSI is calculated as follows, using\na configurable coefficient ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," (default 0.5):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"relativeRSSI = c*rawAdcRssi - a*IF - b*RF\n")),(0,i.kt)("p",null,'The algorithm filters the RSSI using a "fast drop slow rise" infinite impulse\nresponse (IIR) filter, and then computes the maximum AGC and minimum RSSI using\nthe filtered output and a configured margin.'),(0,i.kt)("p",null,"In summary:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"RSSI is reported by the PHY."),(0,i.kt)("li",{parentName:"ol"},'Filter the RSSI using "fast drop slow rise" IIR filter.'),(0,i.kt)("li",{parentName:"ol"},"Subtract the configurable margin from the filtered RSSI (this is the minimum\nRSSI)."),(0,i.kt)("li",{parentName:"ol"},"Optionally, calculate the corresponding IF and RF gains."),(0,i.kt)("li",{parentName:"ol"},"Configure the hardware with either the minimum RSSI or the maximum AGC IF and\nRF gains.")),(0,i.kt)("h3",{id:"calculating-gains"},"Calculating Gains"),(0,i.kt)("p",null,"The IF and RF gains are calculated given the RSSI target, and are configured\nusing vendor-proprietary indices. By default, this assumes 1.0dB per IF index\nand 7.0dB per RF index (as mentioned above). There is also a vendor-proprietary\nand configurable range for each index. By default, the IF gain index can be\n","[0:31]"," and the RF gain index can be ","[0:5]","."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"useMinRssi")," is not set and the raw ADC RSSI is reported, the actual raw\nADC RSSI might differ from the desired raw ADC RSSI target. The IF and RF gains\nare normally set such that the raw ADC RSSI will hit a desired target, ensuring\nthe signal does not clip and thus minimizing quantization noise. If the reported\nraw ADC RSSI is not equal to the desired level, the gains are adjusted\naccordingly."),(0,i.kt)("p",null,"The mapping from RSSI to IF and RF gains is not unique given the ranges above;\nfor example, ",(0,i.kt)("inlineCode",{parentName:"p"},"IF = 3, RF = 2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IF = 10, RF = 1"),' both have the same gain. To\ndeal with this, a "sweet" IF gain range can be configured such that RF gain will\nbe chosen to keep the IF gain within the "sweet" range. By default, this is\nbetween 7 and 17. By keeping the sweet range larger than the RF gain step,\nthrashing can be prevented where the IF and RF gains keep switching back and\nforth, e.g. between ',(0,i.kt)("inlineCode",{parentName:"p"},"IF = 3, RF = 2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IF = 9, RF = 1"),"."),(0,i.kt)("h4",{id:"details"},"Details"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"target RSSI = filtered RSSI - margin = -a*XIF -b*XRF + c*targetRawAdc\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"XIF")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"XRF")," are the desired gains to calculate. ",(0,i.kt)("inlineCode",{parentName:"p"},"targetRawAdc")," is a\nconfigurable input (default -14), and ",(0,i.kt)("inlineCode",{parentName:"p"},"margin")," is the configurable margin (in\ndB)."),(0,i.kt)("p",null,"Let target gain be defined as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"targetGain := filtered RSSI - margin - c*targetRawAdc\n")),(0,i.kt)("p",null,"Given that ",(0,i.kt)("inlineCode",{parentName:"p"},"XRF")," is the current RF gain, ",(0,i.kt)("inlineCode",{parentName:"p"},"XIF")," is calculated as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"XRF = current RF\nXIF = -(targetGain + b*XRF) / a\n")),(0,i.kt)("p",null,"Now, if ",(0,i.kt)("inlineCode",{parentName:"p"},"XIF")," is outside the sweet range, ",(0,i.kt)("inlineCode",{parentName:"p"},"XRF")," is incremented or decremented to\ntry and move it into the sweet range, or until hitting the RF range limit."),(0,i.kt)("h3",{id:"p2mp"},"P2MP"),(0,i.kt)("p",null,"In a point-to-multipoint scenario, a node receives signals from multiple sources\nand the RSSI from each source can differ. There is a configurable option to set\nthe maximum gain and minimum RSSI to the smallest amongst all signals, or to set\neach maximum gain and minimum RSSI separately for each station (i.e. link)."),(0,i.kt)("h3",{id:"rf-gain-hilo"},"RF Gain Hi/Lo"),(0,i.kt)("p",null,"This is a vendor-proprietary option where RF gain selection (1 or 0) is selected\naccording to the measured SNR and a threshold, including hysteresis\n(hysteresis is 1dB - not configurable):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"if SNR > threshold + hysteresis:\n  RFgain = 1\n\nif SNR < threshold - hysteresis:\n  RFgain = 0\n\nif threshold - hysteresis < SNR < threshold + hysteresis:\n  RFgain remains at the current setting\n")),(0,i.kt)("h3",{id:"configuration-options"},"Configuration Options"),(0,i.kt)("p",null,"The firmware configuration options for AGC are listed in the table below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcIfGaindBperIndexQ8")),(0,i.kt)("td",{parentName:"tr",align:null},"The ",(0,i.kt)("inlineCode",{parentName:"td"},"a")," coefficient above (default 1.0dB)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMaxRfGainIndex")),(0,i.kt)("td",{parentName:"tr",align:null},"The maximum allowed RF gain index (default 5)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMinRfGainIndex")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum allowed RF gain index (default 0)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMaxIfGainIndex")),(0,i.kt)("td",{parentName:"tr",align:null},"The maximum allowed IF gain index (default 31)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMinIfGainIndex")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum allowed IF gain index (default 0)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMaxIfSweetGainRange")),(0,i.kt)("td",{parentName:"tr",align:null},"See discussion on sweet IF range above (default 17)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMinIfSweetGainRange")),(0,i.kt)("td",{parentName:"tr",align:null},"See discussion on sweet IF range above (default 7)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcMinRssi")),(0,i.kt)("td",{parentName:"tr",align:null},"If maximum AGC tracking is disabled, a fixed value can be used for minRSSI or maximum AGC (based on ",(0,i.kt)("inlineCode",{parentName:"td"},"useMinRssi"),") (default -40)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcRawAdcScaleFactorQ8")),(0,i.kt)("td",{parentName:"tr",align:null},"The ",(0,i.kt)("inlineCode",{parentName:"td"},"c")," coefficient above (default 0.5dB)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcRfGaindBperIndexQ8")),(0,i.kt)("td",{parentName:"tr",align:null},"The ",(0,i.kt)("inlineCode",{parentName:"td"},"b")," coefficient above (default 7.0dB)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcTargetRawAdc")),(0,i.kt)("td",{parentName:"tr",align:null},"The target raw ADC RSSI described above (default -14)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcTrackingEnabled")),(0,i.kt)("td",{parentName:"tr",align:null},"Enables run-time tracking (default 1)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcTrackingMargindB")),(0,i.kt)("td",{parentName:"tr",align:null},"The margin described above (default 7dB)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcUseMinRssi")),(0,i.kt)("td",{parentName:"tr",align:null},"Determines whether to use minRSSI or maximum AGC (default 0)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcUseSameForAllSta")),(0,i.kt)("td",{parentName:"tr",align:null},"See discussion on P2MP above (default 1)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxAgcRfGainHiLo")),(0,i.kt)("td",{parentName:"tr",align:null},"Setting bit 0 to ",(0,i.kt)("inlineCode",{parentName:"td"},"1")," enables the feature; bits 15:8 represent the threshold (dB) (default 0)")))),(0,i.kt)("h3",{id:"dynamic-agc-configuration"},"Dynamic AGC Configuration"),(0,i.kt)("p",null,"There are two mechanisms for changing AGC parameters on-the-fly while a link\nis up without interrupting service. These mechanisms are described below."),(0,i.kt)("h4",{id:"using-fw_config_req"},"Using FW_CONFIG_REQ"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"FW_CONFIG_REQ")," command can be issued via the TG CLI or r2d2, instructing\nthe E2E minion to apply new firmware parameters on-the-fly."),(0,i.kt)("p",null,"This method supports only a subset of all firmware parameters. The available\nparameters can be listed using the TG CLI:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ tg fw node -n <any dummy value> set_fw_params -s\n")),(0,i.kt)("p",null,"Example usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# Set a link parameter via TG CLI\n$ tg fw node -n <node name> set_fw_params -r <peer node name> <parameter> <value>\n\n# Set a link parameter via r2d2\n$ r2d2 fw_set_params -m <peer MAC address> <parameter> <value>\n\n# Get the current value of a link parameter via TG CLI\n$ tg fw node -n <node name> get_fw_params linkParams -r <peer node name>\n")),(0,i.kt)("h4",{id:"using-phyagcparams"},"Using PhyAgcParams"),(0,i.kt)("p",null,"The entire ",(0,i.kt)("inlineCode",{parentName:"p"},"PhyAgcParams")," Thrift structure can be passed via r2d2 only, which\nissues the same ",(0,i.kt)("inlineCode",{parentName:"p"},"FW_CONFIG_REQ")," command from above to the driver interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ r2d2 phyagc_config -m <peer mac> -f <configuration file>\n")),(0,i.kt)("p",null,"An example configuration file is included in the node image at\n",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/e2e_config/fw_phyagc_cfg.json"),"."),(0,i.kt)("h2",{id:"link-adaptation-and-transmit-power-control-latpc"},"Link Adaptation and Transmit Power Control (LA/TPC)"),(0,i.kt)("p",null,"The modulation and code rate (MCS) and transmit power are both adaptive values,\nand are set at the transmitter independently for every link and for both\ndirections. The adaptive MCS selection procedure is referred to as ",(0,i.kt)("em",{parentName:"p"},"link\nadaptation (LA)"),", and the transmit power procedure as ",(0,i.kt)("em",{parentName:"p"},"transmit power control\n(TPC)"),". Both procedures can be enabled or disabled independently at\ninitialization time or runtime."),(0,i.kt)("p",null,"The algorithm is driven by an ",(0,i.kt)("em",{parentName:"p"},"offset"),". The offset increases as feedback\nindicates good behavior and reduces as feedback indicates negative behavior.\nWhen the offset crosses a fixed threshold (+1dB), MCS generally increases or\npower generally decreases. The opposite is true if the offset crosses a negative\nfixed threshold (-0.5dB). After crossing a threshold, the offset returns to\nzero. The offset can never go outside the range +/- 2dB. The algorithm tries to\nmaximize throughput first by maximizing the MCS, then it will reduce power."),(0,i.kt)("p",null,"When there is data traffic, the offset is driven by the LDPC-based block error\nrate (BLER) reported every SF (1.6ms). A lower BLER causes the algorithm to\nincrease the offset. When there is no data traffic, the algorithm is driven by\nthe STF SNR as reported each mgmt packet (every BWGD). The SNR is compared to\nthe MCS table and if the SNR > (<) table value, the offset will\nincrease (decrease)."),(0,i.kt)("h3",{id:"traffic-driven-mode"},"Traffic-Driven Mode"),(0,i.kt)("p",null,"Every superframe (SF), a new set of LDPC statistics is received.  A ",(0,i.kt)("inlineCode",{parentName:"p"},"deltaOffset"),"\nis calculated:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deltaOffset = (1-PER)*convergenceFactor/nackWeightFactor - PER*convergenceFactor"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"default convergenceFactor = 1.0dB"),(0,i.kt)("li",{parentName:"ul"},"default nackWeightFactor is 200 (5e-3 target PER)"),(0,i.kt)("li",{parentName:"ul"},"PER is calculated from the syndrome error rate",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"PER = nSyn/nCW*bler2perFactor",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"nSyn = syndrome count over the last SF"),(0,i.kt)("li",{parentName:"ul"},"nCW = number of LDPC codewords over the last SF"),(0,i.kt)("li",{parentName:"ul"},"bler2perFactor: see BLER to PER below"))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"offset = offset + deltaOffset"))),(0,i.kt)("p",null,"The speed of the algorithm is determined by ",(0,i.kt)("inlineCode",{parentName:"p"},"convergenceFactor")," and the\ntarget PER is by ",(0,i.kt)("inlineCode",{parentName:"p"},"nackWeightFactor"),".  Both are configurable as a FW\nparameter."),(0,i.kt)("h3",{id:"no-traffic-mode"},"No-Traffic Mode"),(0,i.kt)("p",null,"The traffic-driven mode uses LDPC statistics to drive the MCS/txPower. If no (or\nvery few) data packets are sent, there are no LDPC statistics. In this case, we\nuse the no-traffic mode which uses an MCS table lookup based on SNR."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Detection of traffic:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"if, in any one SF, there are no transmitted MPDUs, then\n",(0,i.kt)("inlineCode",{parentName:"li"},"noTrafficDuration++")),(0,i.kt)("li",{parentName:"ul"},"if there is no traffic for 125 superframes (200ms total, not\nconfigurable), then move to the no-traffic mode"),(0,i.kt)("li",{parentName:"ul"},"as soon as >=1 MDPUs are transmitted, algorithm sets noTrafficDuration = 0\nand moves back to traffic mode")))),(0,i.kt)("p",null,"In no-traffic mode:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"max MCS = min(configured max MCS, noTrafficMaxMcsFallback)"),(0,i.kt)("li",{parentName:"ul"},"default noTrafficMaxMcsFallback is 9 (configurable)"),(0,i.kt)("li",{parentName:"ul"},"offset = ",(0,i.kt)("inlineCode",{parentName:"li"},"effective SNR - MCStable[curMCS]")," (note: this is not the\ndeltaOffset, it's the offset)")),(0,i.kt)("h3",{id:"core-algorithm"},"Core Algorithm"),(0,i.kt)("p",null,'The core algorithm takes the offset and current MCS and txPower and returns the\nnew MCS and txPower.  When the offset crosses the negative threshold (-0.5dB),\nMCS and power follow the "Bad" Path and follow the "Good" Path when the offset\ncrosses the positive threshold (+1.0dB).'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if offset < -0.5dB",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"if not at max power (see ",(0,i.kt)("em",{parentName:"li"},"note 1"),"); ",(0,i.kt)("inlineCode",{parentName:"li"},"txPower++")),(0,i.kt)("li",{parentName:"ul"},"else if not at min MCS; MCS to next lower value (see ",(0,i.kt)("em",{parentName:"li"},"note 2"),")"),(0,i.kt)("li",{parentName:"ul"},"if MCS or power changed, ",(0,i.kt)("inlineCode",{parentName:"li"},"offset = 0")))),(0,i.kt)("li",{parentName:"ul"},"else if offset > +1.0dB",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"if there is enough headroom to increase power and MCS, then do both"),(0,i.kt)("li",{parentName:"ul"},"else if there is room to lower power, then lower power"),(0,i.kt)("li",{parentName:"ul"},"if MCS or power changed, ",(0,i.kt)("inlineCode",{parentName:"li"},"offset = 0"))))),(0,i.kt)("p",null,"Notes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The maximum power is the minimum of the global txMaxPower and the\nmax power per MCS (both configurable)."),(0,i.kt)("li",{parentName:"ol"},"LA/TPC skips MCS5 because MCS6 is a higher rate and lower SNR.")),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/figures/latpc_waterfill.svg",width:"620"})),(0,i.kt)("p",null,"When the offset is good, the algorithm increases both power and MCS at the same\ntime. The reason is that a transition from ",(0,i.kt)("inlineCode",{parentName:"p"},"MCS(n)")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"MCS(n+1)")," requires a\npower increase that depends on ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),". The amount\nof power increase is determined by the difference in SNR in the MCS table\nbetween ",(0,i.kt)("inlineCode",{parentName:"p"},"MCS(n)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MCS(n+1)")," and depends on the transmit power table.\nIf the calculated power increase pushes the power above the\nconfigured maximum, then LA/TPC will reduce power by one index instead of\nincreasing MCS and power. It will continue to reduce power until there is enough\nheadroom to increase both power and MCS."),(0,i.kt)("p",null,"In this case where the offset is good, \u0394 = ",(0,i.kt)("inlineCode",{parentName:"p"},"MCS(n+1) - MCS(n)"),".  The power index\ncontinues to increase while the change in power is less than \u0394 and while\nit is less than the maximum allowed power.  For example,\nassuming that every transmit power index change corresponds to 0.5dB and if\n\u0394 = 1.5dB, then the power will increase 2 indices.\nIf \u0394 = 1.75dB, the power would increase by 3 indices."),(0,i.kt)("p",null,"During a transition from no-traffic mode to traffic mode, MCS can increase\nwithout increasing power. This prevents a ramp in power every time we transition\nfrom no-traffic to traffic modes. MCS will continue to increase until the offset\ncrosses the negative threshold at which point the algorithm returns to the\nnormal mode described above."),(0,i.kt)("p",null,"When the offset is bad, the algorithm is simpler - it will reduce the power\nuntil it hits the limit then it will reduce the MCS."),(0,i.kt)("h3",{id:"latpc-configuration"},"LA/TPC Configuration"),(0,i.kt)("p",null,"LA is enabled if the ",(0,i.kt)("inlineCode",{parentName:"p"},"mcs")," configuration value is 35, with lower and upper\nbounds set to ",(0,i.kt)("inlineCode",{parentName:"p"},"laMinMcs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"laMaxMcs")," respectively. Setting any other valid\n",(0,i.kt)("inlineCode",{parentName:"p"},"mcs")," value disables LA and freezes the MCS at the given value."),(0,i.kt)("p",null,"TPC is enabled if the ",(0,i.kt)("inlineCode",{parentName:"p"},"tpcEnable")," configuration value is 3, with lower and upper\nbounds set at ",(0,i.kt)("inlineCode",{parentName:"p"},"minTxPower")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"maxTxPower")," respectively. Initializing\n",(0,i.kt)("inlineCode",{parentName:"p"},"tpcEnable")," to 0 disables TPC and freezes the transmit power at the ",(0,i.kt)("inlineCode",{parentName:"p"},"txPower"),"\nvalue. If ",(0,i.kt)("inlineCode",{parentName:"p"},"tpcEnable")," is disabled during runtime, the power will be fixed at the\ncurrent value instead."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"txPower")," value is an index between 0 and 31. The TPC algorithm expects that\nthe actual transmit power will monotonically increase as the index increases,\nand also expects approximately 1dB of increase per index (but this need not be\nprecise). The actual power will depend on the number of antenna arrays and is\nvendor-specific."),(0,i.kt)("p",null,"The MCS table is configurable at both initialization time and during runtime\n(all links use the same MCS table in P2MP). At initialization time, it is\nconfigurable using the 4 parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"mcsLqmQ3_1_4"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"mcsLqmQ3_5_8"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"mcsLqmQ3_9_12"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"mcsLqmQ3_13_16")," corresponding to MCS 1-4, 5-8, 9-12, and\n13-16 (EDMG only). Each parameter has 4 MCS SNR values packed in Q3 format\n(times 2^3), 8 bits per value. For example, the SNR corresponding to MCS2 is\n",(0,i.kt)("inlineCode",{parentName:"p"},"(mcsLqmQ3_1_4 >> 8) & 0xff"),". There is a MATLAB script in the ",(0,i.kt)("inlineCode",{parentName:"p"},"utils")," directory\n(",(0,i.kt)("inlineCode",{parentName:"p"},"fw_cfg_mcs_table.m"),") that will convert the MCS table into this packed\nnotation. The MATLAB also contains code to convert the packed notation back into\nunpacked."),(0,i.kt)("p",null,"To configure the MCS table at runtime, issue the r2d2 command below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ r2d2 phyla_config -m <peer MAC addr> -f /path/to/fw_phyla_cfg.json\n")),(0,i.kt)("p",null,"There is an example of this file in ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/e2e_config/fw_phyla_cfg.json"),". Runtime\nconfiguration is only for debugging (it is not supported from the E2E)."),(0,i.kt)("h3",{id:"bler-to-per"},"BLER to PER"),(0,i.kt)("p",null,"When there is data traffic, LA/TPC is driven by the LDPC block error rate (BLER)\nas reported in the block acks. The LDPC BLER is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"nSyn/nCW\n")),(0,i.kt)("p",null,"where nSyn is the number of syndromes and nCW the number of LDPC codewords.\nThe packet error rate (PER) is estimated from the BLER as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"PER ~= BLER2PER_factor * nSyn/nCW\n")),(0,i.kt)("p",null,"We have found through experimentation that BLER2PER_factor is approximately 30.\nOccasionally, there can be short (~10ms) periods of PER that are not caused by\nthe channel. To reduce sensitivity, BLER2PER_factor includes an exponential ramp\nthat increases by a factor of 2 for every SF with BLER > 0 up to an upper limit.\nWhen the BLER is 0, BLER2PER_factor is set to a lower limit. An exception is\nimmediately after a change in power or MCS - in this case, BLER2PER_factor is\nset to the upper limit to react quickly to errors caused by MCS/power changes."),(0,i.kt)("p",null,"The lower and upper limits are configurable using ",(0,i.kt)("inlineCode",{parentName:"p"},"latpcBlerToPer")," as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Bit Mask"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Default"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bits 3:0"),(0,i.kt)("td",{parentName:"tr",align:null},"Lower limit = 2^n for n = bits 3:0"),(0,i.kt)("td",{parentName:"tr",align:null},"1 (lower limit = 2)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bits 7:4"),(0,i.kt)("td",{parentName:"tr",align:null},"Upper limit = 2^n for n = bits 7:4"),(0,i.kt)("td",{parentName:"tr",align:null},"5 (upper limit = 32)")))),(0,i.kt)("p",null,"The overall default for ",(0,i.kt)("inlineCode",{parentName:"p"},"latpcBlerToPer")," is therefore 81 or 0x51."),(0,i.kt)("h3",{id:"setting-maximum-transmit-power-per-mcs"},"Setting Maximum Transmit Power Per MCS"),(0,i.kt)("p",null,"To handle non-linear distortion at high power, it is possible to limit the\nmaximum transmit power per MCS at high transmit powers. Without this capability,\nthe algorithm would always assume that higher power is better and increase the\ntransmit power when there are errors. Setting the maximum power per MCS informs\nthe algorithm that when it increases the transmit power, it may also need to\nlower the MCS."),(0,i.kt)("p",null,"The maximum transmit power per MCS is determined by the configuration values\n",(0,i.kt)("inlineCode",{parentName:"p"},"maxTxPowerPerMcs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"maxTxPowerPerMcsEdmg")," (for EDMG only). MCS values are\ndivided into the following ranges/values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[1-9, 10, 11, 12, 13, 14, 15, 16]\n")),(0,i.kt)("p",null,"The maximum power can be set independently for each of these ranges/values, with\na hard upper limit of ",(0,i.kt)("inlineCode",{parentName:"p"},"maxTxPower")," (the global limit)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"maxTxPowerPerMcs")," is a 4-byte number, where each byte represents the maximum\npower for an MCS range/value. The least significant byte (LSB) corresponds to\nthe first range/value (i.e. MCS 1-9). For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"maxTxPowerPerMcs = 0x1115181c (hex) or 286595100 (dec)\n- max power for MCS  [12] = 0x11 (hex) or 17 (dec)\n- max power for MCS  [11] = 0x15 (hex) or 21 (dec)\n- max power for MCS  [10] = 0x18 (hex) or 24 (dec)\n- max power for MCS [1-9] = 0x1c (hex) or 28 (dec)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"maxTxPowerPerMcsEdmg")," extends the configuration to MCS 13, 14, 15, and 16. The\nLSB corresponds to MCS 13. This value only takes effect when ",(0,i.kt)("inlineCode",{parentName:"p"},"cb2Enable")," is set,\nwhich enables the EDMG MCS levels."),(0,i.kt)("h3",{id:"data-traffic-vs-no-data-traffic"},"Data Traffic vs. No Data Traffic"),(0,i.kt)("p",null,"LA/TPC is normally driven by the packet error rate (PER). When there is very\nlittle or no data traffic, the PER cannot be measured, and SNR is used instead\nuntil data traffic is detected again."),(0,i.kt)("p",null,'If there is no data traffic for 125 consecutive superframes (200ms), the\nalgorithm switches to the "no data traffic" mode. In this mode, the maximum MCS\ntemporarily changes from ',(0,i.kt)("inlineCode",{parentName:"p"},"laMaxMcs")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"noTrafficMaxMcsFallback")," (default 9 for\nDMG and 10 for EDMG). Note that it can take a couple of seconds for the MCS to\nrecover (e.g. to MCS 12 if the fallback is 9)."),(0,i.kt)("h3",{id:"per-target"},"PER Target"),(0,i.kt)("p",null,"As mentioned above, LA/TPC is normally driven by PER. The PER is the receiver\nLDPC-derived PER, which is fed back to the transmitter."),(0,i.kt)("p",null,"The algorithm attempts to stabilize at a PER target, defined as the inverse of\n",(0,i.kt)("inlineCode",{parentName:"p"},"laInvPERTarget"),". The default value of ",(0,i.kt)("inlineCode",{parentName:"p"},"laInvPERTarget")," is 200, making the PER\ntarget 0.005 (or 0.5%). This is a rough, long-term target."),(0,i.kt)("p",null,"If the current PER is above the target, the algorithm will generally increase\nthe power or lower the MCS. If the PER is below the target, the algorithm will\ngenerally, and more slowly, increase the MCS or lower the power."),(0,i.kt)("p",null,"The speed at which the algorithm reacts is governed by\n",(0,i.kt)("inlineCode",{parentName:"p"},"laConvergenceFactordBperSFQ8"),". Changing this value is not recommended."),(0,i.kt)("h3",{id:"100-per-condition"},"100% PER Condition"),(0,i.kt)("p",null,"LA/TPC is driven by LDPC feedback when there is traffic.  When there is 100% PER\nfor an entire PPDU, there might be no LDPC feedback and the transmit counters\n(txOk/txFail) indicate 100% PER. When this happens, the LA/TPC offset is reduced\nby 0.4dB (configurable, see below)."),(0,i.kt)("p",null,"Reasons for 100% can include early-weak interference causing a missed PPDU or a\nmissed block-ack, a calibration event, or can mean that none of the MDPUs were\ndecoded because of low SNR.  In the case of calibration, we don't want to adapt\nthe MCS or power.  The case of early-weak interference is more complicated;\nlowering MCS will not help but increasing the power can. In the low SNR case, we\ndo want to adapt the MCS and/or power."),(0,i.kt)("p",null,"There is no way to know what causes 100% PER.  We assume that calibration\nsuperframes are always isolated meaning that there are always several\nnon-calibration superframes between calibration superframes. Therefore, for each\nlink, LA/TPC will wait for two (configurable) or more data-carrying superframes\nwith 100% PER in a row before reacting.  In that case, we want the offset\nreduction to be 0.8dB when two superframes of 100% are first detected. After\nthen, the offset should return to 0.4dB."),(0,i.kt)("p",null,"The 100% PER algorithm can also disable TPC to prevent a power ramp when\n",(0,i.kt)("inlineCode",{parentName:"p"},"peer SNR > mcsTable[MCS]")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"mcsTable[]")," is a static table of SNR values to\nsupport a given MCS. But as mentioned earlier, this could affect early-weak\ninterference performance."),(0,i.kt)("p",null,"The LA/TPC offset reduction is now configurable (0.4dB is the default). The\nnumber of consecutive superframes of 100% PER is configurable (default is 2; set\nto 1 for no filtering). The feature that disables TPC can also be disabled.\nConfiguration uses bits in ",(0,i.kt)("inlineCode",{parentName:"p"},"latpc100PercentPERDrop")," according to the table\nbelow."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Bit Mask"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Default"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bits 3:0"),(0,i.kt)("td",{parentName:"tr",align:null},"Offset reduction = 0.4dB * (value) / 4"),(0,i.kt)("td",{parentName:"tr",align:null},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bit 4"),(0,i.kt)("td",{parentName:"tr",align:null},"TPC disable feature (1 to allow TPC disable, 0 to not disable TPC)"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bits 10:8"),(0,i.kt)("td",{parentName:"tr",align:null},"Number of consecutive superframes with data"),(0,i.kt)("td",{parentName:"tr",align:null},"2")))),(0,i.kt)("h2",{id:"fast-link-impairment-detection"},"Fast Link Impairment Detection"),(0,i.kt)("p",null,"To enable fast re-routing, the firmware monitors link conditions and signals\nlink impairment to routing protocols when a link is impaired. The goal is to\nreport link impairment in under 50ms. When a link is impaired, the routing\nprotocol will not use the link, and will re-route traffic if another path is\navailable."),(0,i.kt)("p",null,"The Terragraph wireless link remains up as long as MCS 0 management messages are\nsuccessfully exchanged. Data traffic uses MCS >= 1, which requires around\n12dB higher signal-to-noise ratio (SNR) than the management messages. This\nmeans that the link can be up but unable to pass traffic. When this happens,\nthe link state changes from ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN"),"."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"numOfHbLossToFail")," (default 10) management messages are missed, the link\nwill go down (",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_DOWN"),"). Fast link impairment is designed to indicate a\nfailure more quickly than ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_DOWN"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN")," state persists for at least 200 superframes (320ms), or\nlonger if the impairment condition continues."),(0,i.kt)("p",null,"It is possible that link impairment is detected at only one side of a link (e.g.\nif interference is present). A management message is exchanged such that if one\nside enters ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN"),", both sides will enter ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN"),". This\nprevents routing traffic over the link in a single direction."),(0,i.kt)("h3",{id:"conditions-for-link-impairment"},"Conditions for Link Impairment"),(0,i.kt)("p",null,"At a high level, the algorithm monitors link conditions, PER, and management\nmessages, switching to ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN")," upon seeing any of the following\nconditions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A small number of management messages are missed and PER is at 100%."),(0,i.kt)("li",{parentName:"ul"},"LA/TPC wants to reduce MCS or increase power, but MCS/power are already at the\nminimum/maximum (respectively)."),(0,i.kt)("li",{parentName:"ul"},"Many management messages are missed (but fewer than ",(0,i.kt)("inlineCode",{parentName:"li"},"numOfHbLossToFail"),").")),(0,i.kt)("p",null,"Specifically, link impairment is detected using the following condition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(100%PER && (missedHB || SNRlow || farEndSNRlow))\n  || MCS@limit\n  || missedManyHB\n")),(0,i.kt)("p",null,"Each sub-condition is described below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"100%PER"),": 100% ",(0,i.kt)("inlineCode",{parentName:"li"},"txPER")," (use ACK/NACK count) as measured at the transmitter.\nThe condition is that there is a time window with 4 (default, configurable)\nsuperframes with 100% PER and traffic.  The time window is reset\nif there is a superframe with traffic and PER < 100%."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"missedHB"),": 3 (default, configurable) missed received HB/KA/ULBWREQs in a row."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SNRlow"),": SNR measured on HB/KA/ULBWREQ < 2dB (if received). Previous studies\nshowed that even with a bus or truck, sometimes heartbeats can get through."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"farEndSNRlow"),": Peer SNR reported in HB/KA/ULBWREQ < 2dB (as reported through\nHB/KA/ULBWREQ), for the same reason as ",(0,i.kt)("inlineCode",{parentName:"li"},"SNRlow"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MCS@limit"),": If, in any one superframe, the LA/TPC algorithm wants to\nincrease power or decrease MCS but is at the limit, ",(0,i.kt)("inlineCode",{parentName:"li"},"MCS@limitSF")," is set.\nThe condition for ",(0,i.kt)("inlineCode",{parentName:"li"},"MCS@limit")," is that there is a time window with 4\n(default, configurable) superframes with ",(0,i.kt)("inlineCode",{parentName:"li"},"MCS@limitSF")," and traffic.\nA superframe in which ",(0,i.kt)("inlineCode",{parentName:"li"},"MCS@limitSF")," is not set resets the window."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"missedManyHB"),": Missed 5 (default, configurable) HB/KA/ULBWREQ messages in a\nrow. This covers the case of no traffic and truck blockage.")),(0,i.kt)("h4",{id:"configuration-parameters"},"Configuration Parameters"),(0,i.kt)("p",null,"There are four configurable threshold parameters for detecting link impairment.\nThey are encoded in the 32-bit latpcLinkImpairConfig as part of the link\nconfiguration. These parameters can be set per link."),(0,i.kt)("p",null,"The condition for all thresholds is that the condition ",(0,i.kt)("strong",{parentName:"p"},">=")," threshold;\nif the threshold is zero, the condition will always be true."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"100PER")," (bits 3:0)"),(0,i.kt)("td",{parentName:"tr",align:null},"See ",(0,i.kt)("inlineCode",{parentName:"td"},"100%PER")," above. Set to 0xf to disable ",(0,i.kt)("inlineCode",{parentName:"td"},"100%PER"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"missedCnt")," (bits 7:4)"),(0,i.kt)("td",{parentName:"tr",align:null},"See ",(0,i.kt)("inlineCode",{parentName:"td"},"missedHB")," above. Set to 0xf to disable ",(0,i.kt)("inlineCode",{parentName:"td"},"missedHB"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"missedManyCnt")," (bits 11:8)"),(0,i.kt)("td",{parentName:"tr",align:null},"See ",(0,i.kt)("inlineCode",{parentName:"td"},"missedManyHB")," above. Set to 0xf to disable ",(0,i.kt)("inlineCode",{parentName:"td"},"missedManyHB"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"MCSlimit")," (bits 15:12)"),(0,i.kt)("td",{parentName:"tr",align:null},"See ",(0,i.kt)("inlineCode",{parentName:"td"},"MCS@limit")," above. Set to 0xf to disable ",(0,i.kt)("inlineCode",{parentName:"td"},"MCS@limit"))))),(0,i.kt)("h3",{id:"debouncing"},"Debouncing"),(0,i.kt)("p",null,"Debouncing is implemented to prevent rapid transitions between ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN"),". This uses a state machine with states, transition events,\nand times shown in the figure below."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/figures/fast_link_impairment.svg",width:"620"})),(0,i.kt)("p",null,"The normal state is ",(0,i.kt)("inlineCode",{parentName:"p"},"TG_LINK_IMPAIRMENT_LINK_UP"),". If the firmware detects link\nimpairment, it transitions to ",(0,i.kt)("inlineCode",{parentName:"p"},"TG_LINK_IMPAIRMENT_LINK_DOWN")," and sends an event\nto the TG state machine to transition to ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN"),". If there is an\n",(0,i.kt)("inlineCode",{parentName:"p"},"LSM_EVE_LINK_DATAUP")," event, the TG state machine will transition back to\n",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP"),'. All timeouts are in units of superframes (1.6ms). As mentioned\nearlier, "peer link impaired" means that the other end of the link detected link\nimpairment and reported it via a management message.'),(0,i.kt)("h3",{id:"monitoring-link-impairment"},"Monitoring Link Impairment"),(0,i.kt)("p",null,"Two relevant counters (stats) are reported by the firmware every second:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"staPkt.mgmtLinkUp")," - Increments every BWGD when the link is in ",(0,i.kt)("inlineCode",{parentName:"li"},"LINK_UP")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"LINK_UP_DATADOWN"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"staPkt.linkAvailable")," - Increments every BWGD when the link is in ",(0,i.kt)("inlineCode",{parentName:"li"},"LINK_UP"),"\nonly.")),(0,i.kt)("p",null,"If the difference between these two stats increases, then the link entered\n",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN"),". The change in the difference between the two stats indicates\nhow long it was in the ",(0,i.kt)("inlineCode",{parentName:"p"},"LINK_UP_DATADOWN")," state, in units of BWGDs (25.6ms)."))}p.isMDXComponent=!0}}]);