"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7531],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),d=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=d(e.components);return i.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(t),h=a,u=m["".concat(s,".").concat(h)]||m[h]||c[h]||o;return t?i.createElement(u,r(r({ref:n},p),{},{components:t})):i.createElement(u,r({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9437:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=t(7462),a=(t(7294),t(3905));const o={},r="Network Ignition",l={unversionedId:"developer/Network_Ignition",id:"developer/Network_Ignition",title:"Network Ignition",description:'This document describes the link bring-up procedure, or "ignition", at the E2E',source:"@site/../docs/developer/Network_Ignition.md",sourceDirName:"developer",slug:"/developer/Network_Ignition",permalink:"/docs/developer/Network_Ignition",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Network_Ignition.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"Topology Management",permalink:"/docs/developer/Topology_Management"},next:{title:"Software Upgrade",permalink:"/docs/developer/Software_Upgrade"}},s={},d=[{value:"Controller Ignition Management",id:"controller-ignition-management",level:2},{value:"Node Selection",id:"node-selection",level:3},{value:"Slot Exclusion",id:"slot-exclusion",level:3},{value:"Message Exchange",id:"message-exchange",level:3},{value:"Management",id:"management",level:3},{value:"Minion Ignition Procedure",id:"minion-ignition-procedure",level:2},{value:"Overview",id:"overview",level:3},{value:"Link-Layer Security",id:"link-layer-security",level:3},{value:"WPA-PSK",id:"wpa-psk",level:4},{value:"802.1X",id:"8021x",level:4},{value:"Message Exchange",id:"message-exchange-1",level:3},{value:"Initiator",id:"initiator",level:4},{value:"Responder",id:"responder",level:4},{value:"Other Messages",id:"other-messages",level:4},{value:"Distributed Ignition",id:"distributed-ignition",level:2},{value:"Node Configuration",id:"node-configuration",level:3},{value:"Distributed Ignition Procedure",id:"distributed-ignition-procedure",level:3},{value:"Triggers",id:"triggers",level:4},{value:"Time Synchronization",id:"time-synchronization",level:4},{value:"Backoff",id:"backoff",level:4},{value:"Ignition Algorithm",id:"ignition-algorithm",level:4},{value:"Resources",id:"resources",level:2}],p={toc:d};function c(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"network-ignition"},"Network Ignition"),(0,a.kt)("p",null,'This document describes the link bring-up procedure, or "ignition", at the E2E\nlayer.'),(0,a.kt)("h2",{id:"controller-ignition-management"},"Controller Ignition Management"),(0,a.kt)("p",null,"The controller's ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp"),' is responsible for managing the ignition\nprocedure. Ignition involves forming a link from an "initiator" node, which is\nalready connected to the controller in this case, to a "responder" node.'),(0,a.kt)("h3",{id:"node-selection"},"Node Selection"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," will automatically ignite links during network startup and\nwhenever nodes or links subsequently fail. The app periodically runs a procedure\nto select nodes to ignite (every 5 seconds), using the current topology state to\ndetermine the ignition order; multiple links can be ignited in parallel. This\nalgorithm is defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionAppUtil"),", and is described below."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'Determine the set of "candidate" links to ignite, comprised of all offline\nlinks emanating from all currently-reachable nodes. Additionally, the\ninitiator DN on a candidate link must be time-synchronized, i.e. in the\n',(0,a.kt)("inlineCode",{parentName:"li"},"ONLINE_INITIATOR")," state (refer to\n",(0,a.kt)("a",{parentName:"li",href:"/docs/developer/Topology_Management"},"Topology Management")," for further details). Backup\nlinks to CNs are not tried until a minimum time has elapsed (",(0,a.kt)("em",{parentName:"li"},"5 minutes"),", via\ncontroller flag ",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_backup_cn_link_interval"),") since any link to a\nparticular CN could have been considered a candidate."),(0,a.kt)("li",{parentName:"ol"},"An initiator node must wait for the current ignition attempt to finish, fail,\nor time out before accepting another request. On P2MP (point to multi-point)\ninitiator nodes, wait until any response is received (up to ",(0,a.kt)("em",{parentName:"li"},"16 seconds"),", or\ncontroller config ",(0,a.kt)("inlineCode",{parentName:"li"},"ignitionParams.bfTimeoutSec"),") before attempting ignition\nagain for any link."),(0,a.kt)("li",{parentName:"ol"},"When enabled, delay successive ignition attempts on P2MP radios. For example,\nQTI firmware-layer MTPO/autoPBF algorithms may continue to run after\n",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_UP")," is reported, and are needed to move to 4-tile operation and enable\nhigher MCS on the link (ex. MCS12); in this scenario each link requires up to\n12-15 seconds after association to run MTPO/autoPBF. For P2MP radios, a\nsubsequent association request on the same radio may interrupt any ongoing\nprocedures, preventing transition to 4-tile mode and resulting in possibly\nreduced MCS (ex. MCS9). If it is acceptable to incur longer P2MP ignition\ntimes for potentially higher throughput, then post-ignition delays can be\nenabled by setting the controller flag ",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_p2mp_assoc_delay"),' to "15_s".'),(0,a.kt)("li",{parentName:"ol"},"Group candidates by link name. For links that can be ignited in both\ndirections, pick the initiator node randomly and push the other candidate\nnode to the end of the list (in case the first node gets filtered out in a\nsubsequent step)."),(0,a.kt)("li",{parentName:"ol"},"Each node can only have one link ignited at a time, so filter out any\ncandidate links to the same responder node."),(0,a.kt)("li",{parentName:"ol"},"Ignition attempts across the same link are dampened (once per ",(0,a.kt)("em",{parentName:"li"},"10 seconds"),",\nor controller config ",(0,a.kt)("inlineCode",{parentName:"li"},"ignitionParams.linkUpDampenInterval"),"); filter out any\ncandidate links that had ignition attempts within the dampening interval.\nNote that this timeout may get cancelled when the controller receives any\nlink status event for the link (depending on controller flag\n",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_ignore_dampen_interval_after_resp"),"). If the same link fails to\nignite for an extended period (",(0,a.kt)("em",{parentName:"li"},"30 minutes"),", via controller flag\n",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_extended_dampen_failure_interval"),"), the dampening interval is\nincreased (to once per ",(0,a.kt)("em",{parentName:"li"},"5 minutes"),", via controller flag\n",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_extended_dampen_interval"),") in order to reduce possible interference\nto nearby nodes as well as loss of available link bandwidth caused by the\nassociation process.")),(0,a.kt)("p",null,"The controller ignition algorithm has the following limitations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"While Terragraph firmware supports time propagation over ",(0,a.kt)("em",{parentName:"li"},"two hops")," to a CN,\nthe controller only allows ignition from time-synchronized DNs. For example,\nthe following case is unsupported:\n",(0,a.kt)("inlineCode",{parentName:"li"},"DN1 (ONLINE_INITIATOR) -> DN2 (ONLINE) -> CN")),(0,a.kt)("li",{parentName:"ul"},"Each initiator node can only be scheduled once per ignition cycle. On\nmulti-sector DNs, ignition will ",(0,a.kt)("em",{parentName:"li"},"not")," be performed in parallel on different\nsectors, even if this may be feasible depending on interference constraints.")),(0,a.kt)("h3",{id:"slot-exclusion"},"Slot Exclusion"),(0,a.kt)("p",null,"During ignition, the initiator node sweeps its transmit beam in all directions,\nwhich can create interference to nearby nodes. To avoid such interference\npotentially disrupting surrounding links, ",(0,a.kt)("inlineCode",{parentName:"p"},"BF_SLOT_EXCLUSION_REQ")," commands may\nbe sent to nodes in close proximity to an initiator, which instructs them to not\nuse BF slots for the duration of the IBF procedure. This achieves greater link\nstability at the cost of reduced maximum throughput (due to reserved BF slots)."),(0,a.kt)("p",null,"The IBF slot exclusion feature is disabled by default, and can be enabled via\nthe controller flag ",(0,a.kt)("inlineCode",{parentName:"p"},"--enable_linkup_slot_exclusion"),"."),(0,a.kt)("p",null,"The slot exclusion set will include a node/radio if:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"It doesn't have any links being ignited in the current ignition cycle"),(0,a.kt)("li",{parentName:"ol"},"It has polarity opposite of the initiator"),(0,a.kt)("li",{parentName:"ol"},"It uses the same wireless channel as the initiator"),(0,a.kt)("li",{parentName:"ol"},"At least one of the following conditions are met:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Node is within a short distance of an initiator node (",(0,a.kt)("em",{parentName:"li"},"50 meters"),", or\ncontroller flag ",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_exclusion_distance_short"),")"),(0,a.kt)("li",{parentName:"ul"},"Node is within a longer distance of an initiator node (",(0,a.kt)("em",{parentName:"li"},"350 meters"),", or\ncontroller flag ",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_exclusion_distance_long"),") and has one or more\nlinks with receive beam pointing towards the initiator (relative angle\nless than ",(0,a.kt)("em",{parentName:"li"},"5 degrees"),", or controller flag ",(0,a.kt)("inlineCode",{parentName:"li"},"--linkup_exclusion_angle_rel"),")")))),(0,a.kt)("p",null,"For DNs, the ",(0,a.kt)("inlineCode",{parentName:"p"},"BF_SLOT_EXCLUSION_REQ")," is sent to the node subject to interference\nfrom the initiator, whereas for CNs the command is sent to the parent DN."),(0,a.kt)("h3",{id:"message-exchange"},"Message Exchange"),(0,a.kt)("p",null,"At this point, the controller has determined all links to ignite along with\ntheir initiator nodes and any nearby links that require slot exclusion to avoid\ninterference. ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," issues a series of commands to minions, which are\nlisted below."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Send ",(0,a.kt)("inlineCode",{parentName:"li"},"BF_RESP_SCAN")," to any DNs that should now become responders."),(0,a.kt)("li",{parentName:"ol"},"Send ",(0,a.kt)("inlineCode",{parentName:"li"},"BF_SLOT_EXCLUSION_REQ")," to any DN subject to interference that should\navoid using BF slots during this ignition cycle."),(0,a.kt)("li",{parentName:"ol"},"Wait for the previous messages to propagate (1 second)."),(0,a.kt)("li",{parentName:"ol"},"Send ",(0,a.kt)("inlineCode",{parentName:"li"},"SET_LINK_STATUS")," to all initiator nodes, with any required firmware\nparameters (e.g. polarity, control superframe, channel, Golay index).")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"BF_RESP_SCAN")," message instructs nodes to send a ",(0,a.kt)("inlineCode",{parentName:"p"},"FW_BF_RESP_SCAN"),' (ON)\nmessage to the driver, setting the "BF responder mode" config which schedules\nthe BF slot in the slotmap. Before the next ignition cycle, nodes will send a\n',(0,a.kt)("inlineCode",{parentName:"p"},"FW_BF_RESP_SCAN")," (OFF) message to the driver to disable responder mode."),(0,a.kt)("p",null,"Responder mode reserves the Rx BF slots, reducing maximum throughput by roughly\n50%. Each radio starts in responder mode, and goes back into responder mode if\nall links have gone down or whenever a DN-to-DN link has gone down. Note that on\nP2MP DNs, this may cause the radio to go into responder mode regardless of\nwhether there are other links currently up (and causing a throughput drop on\nthose links). Nodes disable responder mode automatically once any link is\nformed. The controller does not need to send these commands to CNs because they\ncan only form one link."),(0,a.kt)("h3",{id:"management"},"Management"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," normally performs network-wide ignition automatically, but accepts\nthe following commands for manual management:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SET_LINK_STATUS_REQ")," - Bring any link up or down via the normal association\nand disassociation procedures, respectively."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"FORCE_DISSOC_REQ")," - Bring down a link forcefully, used when the link may not\nexist in the current topology (e.g. deleted nodes/links)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SET_IGNITION_PARAMS")," - Set ignition parameters, including the time interval\nto run the ignition procedure, the dampening interval, and whether automatic\nignition should be disabled network-wide or on any specific links. Note that\nthese parameters are not persisted, and will be lost if the controller\nreboots."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GET_IGNITION_STATE")," - Retrieve the current ignition parameters, along with\ndebug information about the node selection algorithm.")),(0,a.kt)("p",null,"Note that ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," is always responsible for instructing nodes to report\ntheir link status to ",(0,a.kt)("inlineCode",{parentName:"p"},"TopologyApp"),". If automatic ignition is enabled, this will\nhappen as a result of the ",(0,a.kt)("inlineCode",{parentName:"p"},"SET_LINK_STATUS")," commands. If disabled, then the app\nmanually sends out ",(0,a.kt)("inlineCode",{parentName:"p"},"GET_LINK_STATUS")," commands."),(0,a.kt)("h2",{id:"minion-ignition-procedure"},"Minion Ignition Procedure"),(0,a.kt)("p",null,"The minion's ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," accepts commands from the controller and exchanges\nignition-related messages with the driver to associate or disassociate with a\nneighboring node."),(0,a.kt)("h3",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The ignition procedure begins when the minion receives a ",(0,a.kt)("inlineCode",{parentName:"p"},"SET_LINK_STATUS"),"\ncommand from the controller's ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp"),", and normally ends with a\n",(0,a.kt)("inlineCode",{parentName:"p"},"LINK_STATUS")," notification to the controller's ",(0,a.kt)("inlineCode",{parentName:"p"},"TopologyApp")," indicating the\nstatus of the link. If the link has not come up after a timeout interval (15\nseconds, or ",(0,a.kt)("inlineCode",{parentName:"p"},"FLAGS_linkup_resp_wait_timeout_s"),"), the ignition attempt is\nabandoned and no ",(0,a.kt)("inlineCode",{parentName:"p"},"LINK_STATUS")," message is sent."),(0,a.kt)("p",null,"Only one neighbor can be ignited at a time. The minion starts the process by\nsending a ",(0,a.kt)("inlineCode",{parentName:"p"},"DR_SET_LINK_STATUS")," command to the driver, which attempts to form a\nlink using the parameters received from the controller (e.g. polarity, control\nsuperframe, Golay index). Afterwards, the driver will pass a ",(0,a.kt)("inlineCode",{parentName:"p"},"DR_LINK_STATUS"),"\nmessage back to the minion indicating the link status."),(0,a.kt)("a",{id:"network-ignition-link-layer-security"}),(0,a.kt)("h3",{id:"link-layer-security"},"Link-Layer Security"),(0,a.kt)("p",null,'When link-layer encryption ("wsec") is enabled on the minion, ',(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp"),' also\nbecomes responsible for managing two additional Linux processes for each\nwireless interface: an "authenticator" (',(0,a.kt)("inlineCode",{parentName:"p"},"hostapd"),') on the initiator node and a\n"supplicant" (',(0,a.kt)("inlineCode",{parentName:"p"},"wpa_supplicant"),") on the responder node. Logs for these processes\nare written to ",(0,a.kt)("inlineCode",{parentName:"p"},"/tmp/hostapd_<iface>")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"/var/log/wpa_supplicant.log"),",\nrespectively, with logging verbosity determined by the ",(0,a.kt)("inlineCode",{parentName:"p"},"wsecParams")," node\nconfiguration field. These processes cannot both be enabled on the same\ninterface. The current implementation uses a global ",(0,a.kt)("inlineCode",{parentName:"p"},"wpa_supplicant")," process but\nspawns a separate ",(0,a.kt)("inlineCode",{parentName:"p"},"hostapd")," process for each interface due to limitations in\n",(0,a.kt)("inlineCode",{parentName:"p"},"hostapd")," software."),(0,a.kt)("p",null,"Terragraph nodes support two wsec authentication mechanisms:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"WPA-PSK (",(0,a.kt)("inlineCode",{parentName:"li"},"wsecEnable = 1"),")"),(0,a.kt)("li",{parentName:"ol"},"WPA-Enterprise / 802.1X (",(0,a.kt)("inlineCode",{parentName:"li"},"wsecEnable = 2"),")")),(0,a.kt)("p",null,"Each authentication mechanism uses a different configuration template for the\nauthenticator and supplicant. Under 802.1X, some configurations are populated\nfrom the node configuration, and confidential fields (e.g. passwords) are pulled\nfrom device-specific secure storage and submitted via ",(0,a.kt)("inlineCode",{parentName:"p"},"hostapd_cli")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"wpa_cli"),"."),(0,a.kt)("p",null,"The minion assumes a responder role on startup and runs the supplicant for every\ninterface. When a minion becomes the initiator for a link, it must remove the\nlink's interface from the supplicant and start the authenticator. To do so, the\nminion first requests the interface name by sending a ",(0,a.kt)("inlineCode",{parentName:"p"},"DR_DEV_ALLOC_REQ")," request\nto the driver; it receives a ",(0,a.kt)("inlineCode",{parentName:"p"},"DR_DEV_ALLOC_RES")," response. If association is\nsuccessful, then the authenticator will continue to run on this interface. If\nthe ignition times out or the link goes down, then the minion returns to its\ninitial state by killing the authenticator and re-adding the interface to the\nsupplicant. The responder node should also reset its supplicant interface state\nas a safety measure. Between stopping one service and starting the other, the\nminion must wait for the interface to reset and become available for use again;\nthis is a static duration which may need to be tuned based on the host hardware\nvia the flag ",(0,a.kt)("inlineCode",{parentName:"p"},"--wsec_stop_delay_ms")," (default 200ms)."),(0,a.kt)("p",null,'After association, the minion must wait for the secure port to be set to the\n"authorized" state following successful key negotiation. This is signaled by the\n',(0,a.kt)("inlineCode",{parentName:"p"},"DR_WSEC_LINKUP_STATUS")," event from the driver, after which the minion will\nforward a corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"LINK_AUTHORIZED")," notification to the controller. While\nwaiting for key negotiation, the minion must not ignite other links.\nAdditionally, no other authenticator or supplicant processes should be started\nor stopped; this means that actions for all ",(0,a.kt)("inlineCode",{parentName:"p"},"LINK_DOWN")," messages on other\ninterfaces should be queued for after the key negotiation (or failure/timeout)."),(0,a.kt)("p",null,'For CNs, because only one link can be formed, the minion will remove all other\ninterfaces from the supplicant after a link successfully associates (i.e.\nreaches the "authorized" state). On a ',(0,a.kt)("inlineCode",{parentName:"p"},"LINK_DOWN")," event, the minion must then\nrestart supplicants on every interface."),(0,a.kt)("p",null,"After a ",(0,a.kt)("inlineCode",{parentName:"p"},"LINK_UP")," event, the driver sends ",(0,a.kt)("inlineCode",{parentName:"p"},"DR_WSEC_STATUS")," to the minion when\nwsec is disabled (in place of ",(0,a.kt)("inlineCode",{parentName:"p"},"DR_WSEC_LINKUP_STATUS"),'). This event is ignored by\nthe minion. Previously, the message was part of an "open mode fallback" feature\nto allow an open connection even when operating in secure mode, where the minion\nwould kill any supplicant or authenticator on the given interface to allow the\nconnection to complete. This fallback feature is no longer supported in\nfirmware.'),(0,a.kt)("h4",{id:"wpa-psk"},"WPA-PSK"),(0,a.kt)("p",null,"The default WPA-PSK passphrase (i.e. 8-63 ASCII characters) can be changed via\nthe node configuration field\n",(0,a.kt)("inlineCode",{parentName:"p"},"radioParamsBase.wsecParams.wpaPskParams.wpa_passphrase"),". In addition to the\ndefault passphrase, link-specific passphrases can also be set via the field\n",(0,a.kt)("inlineCode",{parentName:"p"},"radioParamsBase.wsecParams.wpaPskParams.wpa_passphrase_override"),", which maps\nfrom neighbor radio MAC addresses to passphrases."),(0,a.kt)("h4",{id:"8021x"},"802.1X"),(0,a.kt)("p",null,"802.1X requires a RADIUS server to be present in the same network to\nauthenticate requests from the authenticator and supplicant. It also requires\ncertificates to be provisioned to the nodes and to the RADIUS server by the same\ncertificate authority (CA). Nodes support the EAP-TLS protocol."),(0,a.kt)("p",{align:"center"},(0,a.kt)("img",{src:"/figures/802.1X.svg",width:"720"})),(0,a.kt)("p",null,"The authentication process is as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The supplicant initiates the process with the authenticator using EAPoL."),(0,a.kt)("li",{parentName:"ol"},"The authenticator creates a UDP-based TLS tunnel with the RADIUS server using\na shared secret, and forwards EAPoL messages from the supplicant to the\nRADIUS server in this tunnel."),(0,a.kt)("li",{parentName:"ol"},"The supplicant now creates a secure session with the RADIUS server using a\nshared client username and password."),(0,a.kt)("li",{parentName:"ol"},"Once the communication is secured, the supplicant sends the pre-provisioned\ndevice certificate to the RADIUS server."),(0,a.kt)("li",{parentName:"ol"},'The RADIUS server verifies the certificate and sends an "Accept" or "Reject"\nindication (in the UDP datagram header).'),(0,a.kt)("li",{parentName:"ol"},'Upon seeing "Accept", the authenticator proceeds with the creation of an\nencrypted link between the nodes.')),(0,a.kt)("p",null,"Parameters associated with 802.1X reside in the node configuration structure\n",(0,a.kt)("inlineCode",{parentName:"p"},"eapolParams"),"."),(0,a.kt)("h3",{id:"message-exchange-1"},"Message Exchange"),(0,a.kt)("p",null,"The order of the ignition-related messages during association is shown below.\nSteps marked with (","*",") are only applicable in secure mode."),(0,a.kt)("h4",{id:"initiator"},"Initiator"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"SET_LINK_STATUS")," (",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_UP"),") -\nRequest from the controller's ",(0,a.kt)("inlineCode",{parentName:"li"},"IgnitionApp")," to begin igniting a link."),(0,a.kt)("li",{parentName:"ol"},"(","*",") ",(0,a.kt)("inlineCode",{parentName:"li"},"DR_DEV_ALLOC_REQ")," -\nRequest to the driver for the link's interface name."),(0,a.kt)("li",{parentName:"ol"},"(","*",") ",(0,a.kt)("inlineCode",{parentName:"li"},"DR_DEV_ALLOC_RES")," -\nResponse from the driver with the link's interface name, at which point the\nminion removes the interface from the supplicant and starts the\nauthenticator."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"DR_SET_LINK_STATUS")," -\nRequest to the driver to begin igniting a link with the given parameters."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"DR_LINK_STATUS")," (",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_UP"),") -\nEvent from the driver that the association completed and the link is up."),(0,a.kt)("li",{parentName:"ol"},"(","*",") ",(0,a.kt)("inlineCode",{parentName:"li"},"DR_WSEC_LINKUP_STATUS")," -\nEvent from the driver that the secure port is authorized. If operating in\nopen mode, ",(0,a.kt)("inlineCode",{parentName:"li"},"DR_WSEC_STATUS")," will be received instead.")),(0,a.kt)("h4",{id:"responder"},"Responder"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"DR_LINK_STATUS")," (",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_UP"),") -\nEvent from the driver that the association completed and the link is up."),(0,a.kt)("li",{parentName:"ol"},"(","*",") ",(0,a.kt)("inlineCode",{parentName:"li"},"DR_WSEC_LINKUP_STATUS")," -\nEvent from the driver that the secure port is authorized. If operating in\nopen mode, ",(0,a.kt)("inlineCode",{parentName:"li"},"DR_WSEC_STATUS")," will be received instead.")),(0,a.kt)("h4",{id:"other-messages"},"Other Messages"),(0,a.kt)("p",null,"Some other common ignition-related messages are described below."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DR_LINK_STATUS")," (",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_DOWN"),") -\nEvent from the driver that a link went down, including the cause (see\n",(0,a.kt)("inlineCode",{parentName:"li"},"thrift::LinkDownCause"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DR_LINK_STATUS")," (",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_PAUSE"),") -\nEvent from the driver that either end of a link is impaired (i.e. LSM state\n",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_UP_DATADOWN"),'). In this transient state, the link is unusable for data\nbut is still able to pass link-level heartbeats. The "fast link impairment"\nalgorithm will send another ',(0,a.kt)("inlineCode",{parentName:"li"},"LINK_DOWN")," event, this time with cause\n",(0,a.kt)("inlineCode",{parentName:"li"},"HB_KA_LOSS_DETECTED"),", if this condition persists, or transition to\n",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_UP")," if it resolves. The minion treats impaired links in the\n",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_PAUSE")," state as alive, but also brings down links that have been\nimpaired for too long (",(0,a.kt)("inlineCode",{parentName:"li"},"FLAGS_link_pause_dissoc_delay_s"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SET_LINK_STATUS")," (",(0,a.kt)("inlineCode",{parentName:"li"},"LINK_DOWN"),") -\nRequest from the controller's ",(0,a.kt)("inlineCode",{parentName:"li"},"IgnitionApp")," to dissociate a link\n(user-triggered)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DR_DEV_UPDOWN_STATUS")," -\nEvent from the driver (forwarded from ",(0,a.kt)("inlineCode",{parentName:"li"},"StatusApp"),') that a backhaul baseband\ndevice went offline (so all associated links are now also down) or has come\nback online ("up" notification may be emitted twice for unknown reasons).')),(0,a.kt)("h2",{id:"distributed-ignition"},"Distributed Ignition"),(0,a.kt)("p",null,'"Distributed ignition" is a best-effort algorithm for node-initiated link\nignition, where the minion attempts to bring up links to pre-configured\nneighbors until connected to the controller.'),(0,a.kt)("h3",{id:"node-configuration"},"Node Configuration"),(0,a.kt)("p",null,"The minion's ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," attempts distributed ignition using a structure of\none or more (in the case of point-to-multi-point) wireless neighbors defined in\nthe node configuration (",(0,a.kt)("inlineCode",{parentName:"p"},"topologyInfo.neighborInfo"),"). This structure is kept\nup-to-date by the controller, usually immediately but sometimes delayed by up to\n5 minutes (",(0,a.kt)("inlineCode",{parentName:"p"},"FLAGS_topology_info_sync_interval"),")."),(0,a.kt)("p",null,"To improve the likelihood of success and reduce interference, the controller\nassigns a coloring to each radio, and buckets ignition attempts into different\ntime slots based on colors. The total number of colors is defined by the\neven-number constant ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigHelper::kNumColors"),". Radios at the same site should\navoid igniting simultaneously, and radios on opposite ends of a link should also\navoid igniting simultaneously. These constraints match the polarity assignment\nconstraints, so color assignments are based on radio polarity. The color\nassignment algorithm is defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigHelper"),", and is described below."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Divide ",(0,a.kt)("inlineCode",{parentName:"li"},"kNumColors")," by 2 to determine the number of colors available for each\npolarity (with software-hybrid polarity treated as non-hybrid). Radios with\ndifferent polarities will always receive different colors, but radios with\nthe same polarity may receive the same color for small ",(0,a.kt)("inlineCode",{parentName:"li"},"kNumColors"),"."),(0,a.kt)("li",{parentName:"ol"},"For each site in the topology, assign colors as follows:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Compute the approximate angle of every link originating from each radio\nat the site."),(0,a.kt)("li",{parentName:"ol"},"Sort the radios based on link angle."),(0,a.kt)("li",{parentName:"ol"},"Assign colors to each radio based on its polarity and an offset based on\nthe iteration index (i.e. alternating colors in the order of link angle).\nThis aims to reduce same-site interference by picking different colors\nfor adjacent radios. For example, on a site with 4 evenly-spaced\nodd-polarity radios and ",(0,a.kt)("inlineCode",{parentName:"li"},"kNumColors = 4"),", radios 90 degrees apart will\nhave different colors and radios 180 degrees apart will have the same\ncolor.")))),(0,a.kt)("h3",{id:"distributed-ignition-procedure"},"Distributed Ignition Procedure"),(0,a.kt)("p",null,"The minion's ",(0,a.kt)("inlineCode",{parentName:"p"},"IgnitionApp")," manages the distributed ignition procedure via a\n5-second loop (",(0,a.kt)("inlineCode",{parentName:"p"},"FLAGS_distributed_ignition_cooldown_duration_ms"),"). The feature\nis disabled if neighbor information is missing, or if switched off in the node\nconfiguration (",(0,a.kt)("inlineCode",{parentName:"p"},"sysParams.distributedIgnitionEnabled"),")."),(0,a.kt)("h4",{id:"triggers"},"Triggers"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"GPS_ENABLED")," - Event from the driver (forwarded by the minion's ",(0,a.kt)("inlineCode",{parentName:"li"},"StatusApp"),")\nthat the GPS module is initialized. Ignition requires GPS-based time\nsynchronization, so distributed ignition is only enabled after receiving this\nmessage."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"CONTROLLER_CONNECTED")," - Event from the minion's ",(0,a.kt)("inlineCode",{parentName:"li"},"StatusApp")," that\nthe minion is now connected to the controller, which disables the distributed\nignition feature until the minion process restarts.")),(0,a.kt)("p",null,"Note that while distributed ignition is active, the minion will automatically\nenable responder mode on a radio after receiving any ",(0,a.kt)("inlineCode",{parentName:"p"},"LINK_UP")," event, ensuring\nthat links can still be initiated to it if it serves as a P2MP DN in the\ntopology. After connecting to the controller, the minion will switch responder\nmode off on all radios."),(0,a.kt)("h4",{id:"time-synchronization"},"Time Synchronization"),(0,a.kt)("p",null,"Ignition attempts are bucketed into time slots based on each node's GPS clock,\nensuring that all ignition attempts are properly time-synchronized to avoid\ncollisions. The ignition algorithm contains configurable parameters to modify\nthe length of ignition slots and the acceptable time bounds where ignition can\nstill occur before or after a bucket boundary."),(0,a.kt)("p",null,"For example, consider a cooldown duration of 5 seconds, a maximum offset of 1\nsecond (i.e. highest permitted timing error in either direction), and\n",(0,a.kt)("inlineCode",{parentName:"p"},"kNumColors = 4"),". The 4 buckets are distributed into a 20-second time range as\nfollows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Bucket #1 starts at ",(0,a.kt)("em",{parentName:"li"},"t")," seconds (+/- 1 second)"),(0,a.kt)("li",{parentName:"ul"},"Bucket #2 starts at ",(0,a.kt)("em",{parentName:"li"},"t+5")," seconds (+/- 1 second)"),(0,a.kt)("li",{parentName:"ul"},"Bucket #3 starts at ",(0,a.kt)("em",{parentName:"li"},"t+10")," seconds (+/- 1 second)"),(0,a.kt)("li",{parentName:"ul"},"Bucket #4 starts at ",(0,a.kt)("em",{parentName:"li"},"t+15")," seconds (+/- 1 second)")),(0,a.kt)("p",null,"This pattern repeats every 20-second interval on all nodes, based on the current\nGPS time modulo 20 seconds."),(0,a.kt)("h4",{id:"backoff"},"Backoff"),(0,a.kt)("p",null,"To avoid repeated ignition failures for any given link, attempts are subject to\nexponential backoff as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"On the initial ignition failure, set the cooldown time to the total bucket\ntime range (as described above)."),(0,a.kt)("li",{parentName:"ul"},"On each subsequent ignition attempt for the same link, double the cooldown\nduration."),(0,a.kt)("li",{parentName:"ul"},"Randomly delay ignition attempts by an additional cycle (25% of the time).\nThis adds some jitter to prevent repeated synchronized collisions.")),(0,a.kt)("p",null,"Backoff is stored per-link. To achieve quicker ignition, 3 link ignition\nattempts are allowed before beginning the backoff procedure\n(",(0,a.kt)("inlineCode",{parentName:"p"},"FLAGS_distributed_ignition_attempts_before_backoff"),"). After 18 ignition\nattempts, link ignition stops (",(0,a.kt)("inlineCode",{parentName:"p"},"FLAGS_distributed_ignition_max_attempts"),")."),(0,a.kt)("h4",{id:"ignition-algorithm"},"Ignition Algorithm"),(0,a.kt)("p",null,"The minion's distributed ignition algorithm is described below."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Determine the time until the next ignition bucket, and schedule a timer to\nfire at that time."),(0,a.kt)("li",{parentName:"ol"},"When the timer fires, if the current time does not fall within the maximum\nallowed offset for a synchronized attempt slot (i.e. too far from a bucket\nboundary), skip this interval."),(0,a.kt)("li",{parentName:"ol"},"Calculate the bucket index based on the current time and find a viable\ncandidate link. Ignore any links already alive, any links for which the\nbackoff timer has not expired, as well as any links with a color not matching\nthe current bucket."),(0,a.kt)("li",{parentName:"ol"},"Increment the link iteration index. Links from a site are considered in a\nround robin fashion. For example, P2MP radios will attempt to ignite each\nlink once before revisiting previously attempted links.")),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://w1.fi/"},"hostapd and wpa_supplicant")," - IEEE 802.11* wireless security processes")))}c.isMDXComponent=!0}}]);