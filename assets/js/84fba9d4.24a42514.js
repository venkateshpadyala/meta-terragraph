"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2521],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,d=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),k=p(n),c=i,h=k["".concat(d,".").concat(c)]||k[c]||m[c]||r;return n?a.createElement(h,l(l({ref:t},s),{},{components:n})):a.createElement(h,l({ref:t},s))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=k;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},7312:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},l="Driver Stack",o={unversionedId:"developer/Driver_Stack",id:"developer/Driver_Stack",title:"Driver Stack",description:"This document briefly describes Terragraph's driver stack.",source:"@site/../docs/developer/Driver_Stack.md",sourceDirName:"developer",slug:"/developer/Driver_Stack",permalink:"/docs/developer/Driver_Stack",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Driver_Stack.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"Driver Interface",permalink:"/docs/developer/Driver_Interface"},next:{title:"VPP Implementation",permalink:"/docs/developer/VPP_Implementation"}},d={},p=[{value:"Architecture",id:"architecture",level:2},{value:"Kernel Modules",id:"kernel-modules",level:3},{value:"Poll Mode Driver (PMD)",id:"poll-mode-driver-pmd",level:3},{value:"DPDK Applications",id:"dpdk-applications",level:3},{value:"Code Structure",id:"code-structure",level:2},{value:"Kernel Modules",id:"kernel-modules-1",level:3},{value:"Poll Mode Driver (PMD)",id:"poll-mode-driver-pmd-1",level:3},{value:"DPDK Applications",id:"dpdk-applications-1",level:3},{value:"DPDK Device Arguments",id:"dpdk-device-arguments",level:2},{value:"Initialization Procedure",id:"initialization-procedure",level:2},{value:"Initialization",id:"initialization",level:3},{value:"1. Load kernel modules",id:"1-load-kernel-modules",level:4},{value:"2. Configure hugepages",id:"2-configure-hugepages",level:4},{value:"3. Bind wireless devices via dpdk-devbind",id:"3-bind-wireless-devices-via-dpdk-devbind",level:4},{value:"4. Start the DPDK application",id:"4-start-the-dpdk-application",level:4},{value:"5. Invoke <code>DPDK_DHD_ATTACH</code>",id:"5-invoke-dpdk_dhd_attach",level:4},{value:"6. Invoke <code>DPDK_DHD_START</code>",id:"6-invoke-dpdk_dhd_start",level:4},{value:"Shutdown",id:"shutdown",level:3},{value:"MAC Address Assignment",id:"mac-address-assignment",level:2},{value:"Example Message Path",id:"example-message-path",level:2},{value:"Debugging",id:"debugging",level:2},{value:"Driver Logs",id:"driver-logs",level:3},{value:"Poll Mode Driver (PMD) Logs",id:"poll-mode-driver-pmd-logs",level:3},{value:"Firmware/Microcode Logs",id:"firmwaremicrocode-logs",level:3},{value:"Firmware Core Dumps",id:"firmware-core-dumps",level:3},{value:"Kernel Crashes",id:"kernel-crashes",level:3},{value:"Resources",id:"resources",level:2}],s={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"driver-stack"},"Driver Stack"),(0,i.kt)("p",null,"This document briefly describes Terragraph's driver stack."),(0,i.kt)("h2",{id:"architecture"},"Architecture"),(0,i.kt)("p",null,'The driver stack consists of the Terragraph driver and a wireless ("backhaul")\ndriver. Terragraph implements its datapath using ',(0,i.kt)("a",{parentName:"p",href:"https://www.dpdk.org/"},"DPDK"),", a framework for fast\npacket processing in user space, along with its own implementation of a\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210")," Poll Mode Driver (PMD). These components are described below."),(0,i.kt)("h3",{id:"kernel-modules"},"Kernel Modules"),(0,i.kt)("p",null,"The Terragraph driver communicates with underlying hardware using a particular\ntype of interface, and compiles into a corresponding kernel object file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"dhd:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-dhd.ko"),' using the BCM20130 API ("dongle host driver")'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"qwilvendor:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-qca.ko")," using the wil6210 API")),(0,i.kt)("p",null,"Similarly, there are several wireless drivers available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wil6210.ko")," - Wilocity wil6210 kernel driver"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bcmdhd.ko")," - Broadcom BCM20130 driver"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-dhd.ko")," - DPDK driver (with ",(0,i.kt)("inlineCode",{parentName:"li"},"wil6210")," PMD, described below)")),(0,i.kt)("p",null,"The kernel modules loaded for each Terragraph hardware type are listed below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Rev5:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-dhd.ko"),"+",(0,i.kt)("inlineCode",{parentName:"li"},"bcmdhd.ko")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Puma:"),(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-qca.ko"),"+",(0,i.kt)("inlineCode",{parentName:"li"},"wil6210.ko")," (Linux kernel-based datapath) ",(0,i.kt)("em",{parentName:"li"},"OR"),(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-dhd.ko"),"+",(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-dhd.ko")," (DPDK-based datapath)")),(0,i.kt)("h3",{id:"poll-mode-driver-pmd"},"Poll Mode Driver (PMD)"),(0,i.kt)("p",null,"DPDK utilizes Poll Mode Drivers (PMD), which run in the user-space DPDK\nenvironment and continuously poll for data packets."),(0,i.kt)("p",null,"Terragraph has its own PMD implementation, ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210"),", for the Talyn2 chip\n(wil6436) used by Puma. This is a partial port of the corresponding Linux kernel\ndriver ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210.ko"),", and only implements features that are strictly needed."),(0,i.kt)("h3",{id:"dpdk-applications"},"DPDK Applications"),(0,i.kt)("p",null,"DPDK relies on user-space applications to link with its libraries and the\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210")," PMD. For production, Terragraph uses ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.fd.io/view/VPP"},"VPP")," (Vector Packet Processing\nframework). For more details, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/developer/VPP_Implementation"},"VPP Implementation"),"."),(0,i.kt)("p",null,"Other DPDK applications include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://pktgen-dpdk.readthedocs.io/en/latest/"},"Pktgen"),":")," Traffic generator"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://doc.dpdk.org/guides/testpmd_app_ug/"},"Testpmd"),":")," Reference application that forwards packets between Ethernet\nports"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"wiltest:")," Test application that forwards packets from Linux ",(0,i.kt)("inlineCode",{parentName:"li"},"terraX")," netdev\ninterfaces to the appropriate wireless link and back")),(0,i.kt)("h2",{id:"code-structure"},"Code Structure"),(0,i.kt)("p",null,"The sections below provide an overview of the driver stack's code structure."),(0,i.kt)("h3",{id:"kernel-modules-1"},"Kernel Modules"),(0,i.kt)("p",null,"The Terragraph driver sources are located in\n",(0,i.kt)("inlineCode",{parentName:"p"},"recipes-radio/wireless-mod/files/fb_terragraph/"),". These are installed as\nfollows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-qca.ko")," via\n",(0,i.kt)("inlineCode",{parentName:"li"},"recipes-radio/wireless-mod/kernel-module-terragraph-qca_0.1.bb")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-dhd.ko")," via\n",(0,i.kt)("inlineCode",{parentName:"li"},"recipes-radio/wireless-mod/kernel-module-terragraph-dhd_0.1.bb"))),(0,i.kt)("p",null,"The API between the Terragraph and wireless drivers is defined in the header\nfile ",(0,i.kt)("inlineCode",{parentName:"p"},"recipes-radio/wireless-mod/files/nl-driver-if-hdr/fb_tg_backhaul_if.h"),"."),(0,i.kt)("p",null,"The wireless drivers are installed as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wil6210.ko")," via\n",(0,i.kt)("inlineCode",{parentName:"li"},"meta-qca/recipes-radio/wigig-utils-oss/kernel-module-wil6210.bb")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bcmdhd.ko")," via ",(0,i.kt)("inlineCode",{parentName:"li"},"recipes-radio/broadcom-dhd/kernel-module-bcmdhd_0.1.bb"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd.ko")," module sources are fetched with the PMD sources and are\nlocated the in the directory ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk/modules/dpdk-dhd/"),". The module is installed\nalong with the ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210")," PMD."),(0,i.kt)("h3",{id:"poll-mode-driver-pmd-1"},"Poll Mode Driver (PMD)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210")," PMD sources are fetched from the same upstream repository as the\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210.ko")," kernel driver. PMD sources are in the directory\n",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk/drivers/wil6210/")," while kernel driver sources are in the directory\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210/"),". PMD sources are compiled into ",(0,i.kt)("inlineCode",{parentName:"p"},"librte_pmd_wil6210.a")," and installed\nvia ",(0,i.kt)("inlineCode",{parentName:"p"},"meta-qca/recipes-radio/wigig-dpdk/wigig-dpdk_git.bb"),"."),(0,i.kt)("p",null,"The source files for the PMD are prefixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_"),", many of which\nare modified copies of similarly-named files (without the prefix) in the\noriginal ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210.ko")," Linux kernel driver. A compatibility layer,\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_compat.h"),", provides implementations for some Linux-specific APIs since\nthe PMD runs in a non-Linux environment; this makes it possible to take the\nupstream kernel driver code with minimal changes."),(0,i.kt)("p",null,"A subdirectory, ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd-ctrl/"),", contains code to send ",(0,i.kt)("inlineCode",{parentName:"p"},"ioctl")," commands to\n",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/dhd"),", and also to set up ",(0,i.kt)("inlineCode",{parentName:"p"},"AF_PACKET")," queues and required machinery to\nexchange requests between kernel and user space."),(0,i.kt)("h3",{id:"dpdk-applications-1"},"DPDK Applications"),(0,i.kt)("p",null,"The DPDK user-space applications are installed as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://wiki.fd.io/view/VPP"},"VPP"),":")," Installed via ",(0,i.kt)("inlineCode",{parentName:"li"},"meta-qoriq/recipes-extended/vpp/vpp_19.01-lsdk.bb"),".\nFor more details, see ",(0,i.kt)("a",{parentName:"li",href:"/docs/developer/VPP_Implementation"},"VPP Implementation"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://pktgen-dpdk.readthedocs.io/en/latest/"},"Pktgen"),":")," Installed as ",(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-pktgen")," via\n",(0,i.kt)("inlineCode",{parentName:"li"},"meta-qca/recipes-extended/pktgen-dpdk/pktgen-dpdk_git.bb"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("a",{parentName:"strong",href:"https://doc.dpdk.org/guides/testpmd_app_ug/"},"Testpmd"),":")," Not installed by default; part of ",(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-utils")," (see\n",(0,i.kt)("inlineCode",{parentName:"li"},"meta-qoriq/recipes-extended/dpdk/dpdk_19.09-lsdk.bb"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"wiltest:")," Installed via\n",(0,i.kt)("inlineCode",{parentName:"li"},"meta-qca/recipes-radio/wigig-dpdk/wigig-dpdk_git.bb"),". The sources are located\nin ",(0,i.kt)("inlineCode",{parentName:"li"},"src/dpdk/examples/wil6210-test/"),".")),(0,i.kt)("h2",{id:"dpdk-device-arguments"},"DPDK Device Arguments"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210"),' PMD exposes a set of DPDK device arguments (or "devargs") for\nconfiguration, defined in ',(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_pcidev.c"),". These are described in the table\nbelow. Note that flags are set/enabled with a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and unset/disabled\nwith a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Default"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"crash-on-fw-err")),(0,i.kt)("td",{parentName:"tr",align:null},"0*"),(0,i.kt)("td",{parentName:"tr",align:null},"Flag to crash if a firmware error occurs. Note that this is ",(0,i.kt)("em",{parentName:"td"},"enabled")," by default in the driver, but is ",(0,i.kt)("em",{parentName:"td"},"disabled")," in Terragraph's VPP configuration.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"fw-core-dump-path")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"/var/volatile/cores/wil6210_fw_core")),(0,i.kt)("td",{parentName:"tr",align:null},"File path prefix to write core dump to after a firmware crash. The PCI ID and date are appended to the provided path.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"fw-log-level")),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Log level of both firmware and microcode logs (0: ERROR+WARN+INFO, 1: ERROR, 2: +WARN, 3: +INFO, 4: +VERBOSE).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"fw-log-path")),(0,i.kt)("td",{parentName:"tr",align:null},"null"),(0,i.kt)("td",{parentName:"tr",align:null},"File path to write logs to while device runs (enables PMD log polling thread).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"fw-strings")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"/data/firmware/wil6210/fw_image_trace_string_load.bin")),(0,i.kt)("td",{parentName:"tr",align:null},"File path of firmware binary strings file to read logs.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"mac-address")),(0,i.kt)("td",{parentName:"tr",align:null},"null"),(0,i.kt)("td",{parentName:"tr",align:null},"The MAC address to be used by the device, overriding the MAC address ",(0,i.kt)("a",{parentName:"td",href:"#driver-stack-mac-address-assignment"},"read from OTP"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"mtu-max")),(0,i.kt)("td",{parentName:"tr",align:null},"1986"),(0,i.kt)("td",{parentName:"tr",align:null},"Maximum MTU. The default value is computed as ",(0,i.kt)("inlineCode",{parentName:"td"},"TXRX_BUF_LEN_DEFAULT")," (2048) - ",(0,i.kt)("inlineCode",{parentName:"td"},"WIL_MAX_MPDU_OVERHEAD")," (62).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"no-fw-recovery")),(0,i.kt)("td",{parentName:"tr",align:null},"1*"),(0,i.kt)("td",{parentName:"tr",align:null},"Flag to disable firmware recovery. Recovery is currently supported only in VPP, and not in other DPDK applications. Note that this is ",(0,i.kt)("em",{parentName:"td"},"disabled")," by default in the driver (i.e. enabling recovery), but is ",(0,i.kt)("em",{parentName:"td"},"enabled")," in Terragraph's VPP configuration (i.e. disabling recovery).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"non-commercial-rf")),(0,i.kt)("td",{parentName:"tr",align:null},"1*"),(0,i.kt)("td",{parentName:"tr",align:null},"Flag to determine if non-commercial RF is attached to the device. Note that this is ",(0,i.kt)("em",{parentName:"td"},"disabled")," by default in the driver, but is ",(0,i.kt)("em",{parentName:"td"},"enabled")," in Terragraph's VPP configuration.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opaque-log")),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Flag to enable collection of opaque logs without binary strings file (requires ",(0,i.kt)("inlineCode",{parentName:"td"},"fw-log-path"),"/",(0,i.kt)("inlineCode",{parentName:"td"},"ucode-log-path"),").")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"p2mp-capable")),(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"Flag to enable sending a particular WMI command to firmware for P2MP-capable devices.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"pcie-expected-gen")),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Expected PCIe gen value. If it is nonzero and does not match the value read from the device PCIe link status, the driver will retrain the PCIe link before rereading and sending PCIe information to firmware as usual.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"pcie-expected-lanes")),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Expected PCIe lane count. If it is nonzero and does not match the value read from the device PCIe link status, the driver will retrain the PCIe link before rereading and sending PCIe information to firmware as usual.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"pmc-ext-host")),(0,i.kt)("td",{parentName:"tr",align:null},"1*"),(0,i.kt)("td",{parentName:"tr",align:null},"Flag to enable firmware logging to go into the host buffer from the very beginning of firmware initialization. Otherwise the firmware will use device memory for logging initially until the host configures it to use the ring buffer in host memory. Ensures early boot logs are fully captured. Note that this is ",(0,i.kt)("em",{parentName:"td"},"disabled")," by default in the driver, but is ",(0,i.kt)("em",{parentName:"td"},"enabled")," in Terragraph's VPP configuration.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"pmc-ext-ring-order")),(0,i.kt)("td",{parentName:"tr",align:null},"10"),(0,i.kt)("td",{parentName:"tr",align:null},"Determines the size of the ring in host memory used for recording logs (in 2^order units).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ucode-log-path")),(0,i.kt)("td",{parentName:"tr",align:null},"null"),(0,i.kt)("td",{parentName:"tr",align:null},"File path to write microcode logs to while device runs (enables PMD log polling thread).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ucode-strings")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"/data/firmware/wil6210/ucode_image_trace_string_load.bin")),(0,i.kt)("td",{parentName:"tr",align:null},"File path of microcode binary strings file to read logs.")))),(0,i.kt)("p",null,"To manually set devargs when running VPP, add them under the VPP configuration\noption ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk dev <pci_id> devargs")," in the VPP startup configuration file\n(",(0,i.kt)("inlineCode",{parentName:"p"},"/var/run/vpp/startup.conf"),"). Multiple devargs can be provided as a\ncomma-separated list. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"dpdk {\n  dev 0000:01:00.0 {\n    devargs fw-core-dump-path=/tmp/fw_dump.core,fw-strings=/data/fw_string.bin\n  }\n}\n")),(0,i.kt)("p",null,'When using other DPDK applications (e.g. pktgen, wiltest), devargs can be passed\nas part of the "PCI whitelist" (',(0,i.kt)("inlineCode",{parentName:"p"},"--pci-whitelist")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"-w"),") EAL argument, also in\na comma-separated list. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ wiltest -w 0001:01:00.0,fw-log-path=/tmp/fw_logs,opaque-log=1\n")),(0,i.kt)("h2",{id:"initialization-procedure"},"Initialization Procedure"),(0,i.kt)("p",null,"The sections below summarize the driver stack initialization and shutdown\nprocesses using DPDK and the ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210")," PMD."),(0,i.kt)("h3",{id:"initialization"},"Initialization"),(0,i.kt)("h4",{id:"1-load-kernel-modules"},"1. Load kernel modules"),(0,i.kt)("p",null,"Initially, the ",(0,i.kt)("inlineCode",{parentName:"p"},"terragraph-dhd.ko")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd.ko")," kernel modules are loaded:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ modprobe terragraph-dhd && modprobe dpdk-dhd\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd.ko")," registers ",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/dhd"),", a miscellaneous device instance, during\nstartup (in ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd_init()"),"). It then waits for a user-space DPDK application to\nopen ",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/dhd")," and issue ",(0,i.kt)("inlineCode",{parentName:"p"},"ioctl")," commands (handled in ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd_ioctl()"),")."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"pci_order")," module parameter can be used to specify indexing of PCI devices\nfor bringing up ",(0,i.kt)("inlineCode",{parentName:"p"},"dhdX")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"terraX")," devices (the first device gets ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd0"),", next\n",(0,i.kt)("inlineCode",{parentName:"p"},"dhd1"),", etc.). When no ordering is specified, naming follows PCI enumeration\norder. The parameter value should be comma-separated\n",(0,i.kt)("inlineCode",{parentName:"p"},"domain:bus:device.function")," PCI addresses passed as a string and include all\nPCI devices being used. For Puma, the default is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ modprobe dpdk-dhd pci_order="0000:01:00.0,0001:01:00.0,0002:03:00.0,0002:04:00.0"\n')),(0,i.kt)("h4",{id:"2-configure-hugepages"},"2. Configure hugepages"),(0,i.kt)("p",null,"DPDK requires ",(0,i.kt)("a",{parentName:"p",href:"https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"},"hugepages")," for the large memory pool allocation used for packet\nbuffers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ mkdir /mnt/hugepages\n$ mount -t hugetlbfs none /mnt/hugepages\n")),(0,i.kt)("h4",{id:"3-bind-wireless-devices-via-dpdk-devbind"},"3. Bind wireless devices via dpdk-devbind"),(0,i.kt)("p",null,"DPDK requires the wireless devices (i.e. baseband cards) to be made available in\nuser space (and unbound from the Linux kernel), by binding them to either the\n",(0,i.kt)("a",{parentName:"p",href:"https://www.kernel.org/doc/Documentation/vfio.txt"},"VFIO")," or ",(0,i.kt)("a",{parentName:"p",href:"https://www.kernel.org/doc/html/latest/_sources/driver-api/uio-howto.rst.txt"},"UIO")," kernel driver. The baseband cards are PCIe devices, so they are\nbound to the ",(0,i.kt)("inlineCode",{parentName:"p"},"vfio-pci")," driver:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ echo "vfio-pci" > "/sys/bus/pci/devices/<pci_id>/driver_override"\n$ echo "<pci_id>" > "/sys/bus/pci/drivers/vfio-pci/bind"\n')),(0,i.kt)("p",null,"The role of ",(0,i.kt)("inlineCode",{parentName:"p"},"vfio-pci")," is to provide the necessary kernel support to drive the\nhardware from a user-space process safely and efficiently. Specifically,\n",(0,i.kt)("inlineCode",{parentName:"p"},"vfio-pci")," puts the device behind IOMMU (I/O Memory Management Unit) so that it\ncannot use DMA to access arbitrary physical memory, and provides ",(0,i.kt)("inlineCode",{parentName:"p"},"ioctl"),"\ncommands to reflect interrupts from the kernel into the DPDK process. This is\nwell abstracted by DPDK libraries."),(0,i.kt)("h4",{id:"4-start-the-dpdk-application"},"4. Start the DPDK application"),(0,i.kt)("p",null,"At this point, a DPDK application is started and loads the ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210")," PMD, which\nlooks for all available Talyn PCI devices. The PMD defines the ",(0,i.kt)("inlineCode",{parentName:"p"},"net_wil6210")," PCI\ndevice in ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_pcidev.c"),", containing the PCI ID table along with\nprobe/remove routines."),(0,i.kt)("p",null,"During the probe, the PMD invokes ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_dev_init()")," (resembling\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil_pcie_probe()")," from the ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210.ko")," kernel driver). Among other tasks, this\nloads the firmware, performs other low-level initialization, and invokes\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil_register_slave()")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_slave.c")," to expose the ",(0,i.kt)("inlineCode",{parentName:"p"},"qwilvendor")," platform\ndevice. The PMD implements its own ",(0,i.kt)("inlineCode",{parentName:"p"},"platform_device_*")," functions (declared in\nthe Linux API compatibility layer, ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_compat.h"),") in ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_control.c")," to\nuse on this ",(0,i.kt)("inlineCode",{parentName:"p"},"qwilvendor")," device (instead of having it attached to\n",(0,i.kt)("inlineCode",{parentName:"p"},"terragraph-qca.ko"),")."),(0,i.kt)("h4",{id:"5-invoke-dpdk_dhd_attach"},"5. Invoke ",(0,i.kt)("inlineCode",{parentName:"h4"},"DPDK_DHD_ATTACH")),(0,i.kt)("p",null,"Next, the PMD opens ",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/dhd")," and invokes the ",(0,i.kt)("inlineCode",{parentName:"p"},"ioctl")," command ",(0,i.kt)("inlineCode",{parentName:"p"},"DPDK_DHD_ATTACH"),"\n(using ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd_attach()")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd-ctrl.c"),"). In response, ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd.ko")," creates\na Linux network interface (",(0,i.kt)("inlineCode",{parentName:"p"},"dhd0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd2"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd3"),") and returns this\ninformation back to user space. The PMD uses this information to set up\n",(0,i.kt)("inlineCode",{parentName:"p"},"AF_PACKET")," queues for the interface."),(0,i.kt)("h4",{id:"6-invoke-dpdk_dhd_start"},"6. Invoke ",(0,i.kt)("inlineCode",{parentName:"h4"},"DPDK_DHD_START")),(0,i.kt)("p",null,"The PMD then invokes the ",(0,i.kt)("inlineCode",{parentName:"p"},"ioctl")," command ",(0,i.kt)("inlineCode",{parentName:"p"},"DPDK_DHD_START")," (using ",(0,i.kt)("inlineCode",{parentName:"p"},"dhd_start()"),"\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd-ctrl.c"),"). In response, ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd.ko")," registers the ",(0,i.kt)("inlineCode",{parentName:"p"},"terragraph_bh"),"\nplatform device, which gets attached to ",(0,i.kt)("inlineCode",{parentName:"p"},"terragraph-dhd.ko")," (via ",(0,i.kt)("inlineCode",{parentName:"p"},"tg_bh_probe()"),"\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"fb_tgd_terragraph_linux.c"),")."),(0,i.kt)("p",null,"Upon attach, the Terragraph driver creates all of the ",(0,i.kt)("inlineCode",{parentName:"p"},"terraX")," devices, and\nregisters itself with the Netlink subsystem to handle Terragraph-specific\nrequests targeting the backhaul device instance. The Terragraph driver also uses\nan API defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"fb_tg_backhaul_if.h")," to request services, and ",(0,i.kt)("inlineCode",{parentName:"p"},"dpdk-dhd.ko"),"\nconverts these function calls into control request packets with codes\n",(0,i.kt)("inlineCode",{parentName:"p"},"DHD_CMDOP_REGISTER")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DHD_CMDOP_IOCTL")," and sends them back to the DPDK\napplication. The PMD spawns a separate thread to handle these control messages."),(0,i.kt)("p",null,"This concludes the startup process. The driver stack is ready to accept Netlink\nrequests from ",(0,i.kt)("inlineCode",{parentName:"p"},"driver-if"),"."),(0,i.kt)("h3",{id:"shutdown"},"Shutdown"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ioctl")," command ",(0,i.kt)("inlineCode",{parentName:"p"},"DPDK_DHD_STOP")," undoes ",(0,i.kt)("inlineCode",{parentName:"p"},"DPDK_DHD_START")," by unregistering the\n",(0,i.kt)("inlineCode",{parentName:"p"},"terragraph_bh")," platform device. This in turn causes ",(0,i.kt)("inlineCode",{parentName:"p"},"terragraph-dhd.ko")," to\ndetach from it, shutting down and destroying all ",(0,i.kt)("inlineCode",{parentName:"p"},"terraX")," interfaces and\nderegistering from Netlink."),(0,i.kt)("p",null,"The last ",(0,i.kt)("inlineCode",{parentName:"p"},"close()")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/dhd")," file handle undoes ",(0,i.kt)("inlineCode",{parentName:"p"},"DPDK_DHD_ATTACH"),' (there\nis no special "detach" ',(0,i.kt)("inlineCode",{parentName:"p"},"ioctl")," command)."),(0,i.kt)("a",{id:"driver-stack-mac-address-assignment"}),(0,i.kt)("h2",{id:"mac-address-assignment"},"MAC Address Assignment"),(0,i.kt)("p",null,"When using the PMD, the default MAC address of each baseband card will be the\nMAC address read from its one-time-programmable (OTP) memory. This is a unique\nMAC address assigned during manufacturing. It is also possible to assign a\ndifferent MAC address by passing in a value to the devarg ",(0,i.kt)("inlineCode",{parentName:"p"},"mac-address")," when\nstarting DPDK applications. To do this for VPP using the MAC address\n",(0,i.kt)("a",{parentName:"p",href:"/docs/developer/Service_Scripts#service-scripts-environment-variables"},"read from EEPROM"),",\nset the node configuration flag ",(0,i.kt)("inlineCode",{parentName:"p"},"envParams.VPP_USE_EEPROM_MACS"),"."),(0,i.kt)("p",null,"When using the Linux kernel driver, the default MAC address assigned to each\nbaseband card is the MAC address read from EEPROM."),(0,i.kt)("a",{id:"driver-stack-example-message-path"}),(0,i.kt)("h2",{id:"example-message-path"},"Example Message Path"),(0,i.kt)("p",null,"The example below highlights the message path for a user-initiated command, e.g.\nfrom the ",(0,i.kt)("inlineCode",{parentName:"p"},"r2d2")," CLI or ",(0,i.kt)("inlineCode",{parentName:"p"},"e2e_minion"),"."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"/figures/driver_stack_ioctl.svg",width:"850"})),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"driver-if")," receives a message and uses Netlink to send it to the kernel."),(0,i.kt)("li",{parentName:"ol"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-dhd.ko")," Netlink handler receives the request, extracts the\nfirmware parameter blob, and uses an ",(0,i.kt)("inlineCode",{parentName:"li"},"ioctl")," command to send it to\n",(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-dhd.ko"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-dhd.ko")," wraps the request into a control packet and puts it on the\n",(0,i.kt)("inlineCode",{parentName:"li"},"AF_PACKET")," queue for the PMD."),(0,i.kt)("li",{parentName:"ol"},"The PMD event handler thread wakes up, reads the packet data, and hands the\n",(0,i.kt)("inlineCode",{parentName:"li"},"DHD_CMDOP_IOCTL")," message to ",(0,i.kt)("inlineCode",{parentName:"li"},"wil_sync_handler()")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"wil6210_control.c"),".\nThis will invoke the ",(0,i.kt)("inlineCode",{parentName:"li"},"ioctl")," method as implemented by the driver, which uses\na WMI (Wireless Module Interface) control queue to hand the data to the\nfirmware."),(0,i.kt)("li",{parentName:"ol"},"Eventually, firmware responds with the results, and the reverse process\noccurs: the response is placed into the PMD's TX ",(0,i.kt)("inlineCode",{parentName:"li"},"AF_PACKET")," queue, then\n",(0,i.kt)("inlineCode",{parentName:"li"},"dpdk-dhd.ko")," receives it and returns from the ",(0,i.kt)("inlineCode",{parentName:"li"},"ioctl")," call, and finally\n",(0,i.kt)("inlineCode",{parentName:"li"},"terragraph-dhd.ko")," sends the associated response back to ",(0,i.kt)("inlineCode",{parentName:"li"},"driver-if")," over\nNetlink.")),(0,i.kt)("h2",{id:"debugging"},"Debugging"),(0,i.kt)("p",null,"The following sections outline how to obtain logs and crash dumps, specifically\nwith QTI firmware (where applicable)."),(0,i.kt)("h3",{id:"driver-logs"},"Driver Logs"),(0,i.kt)("p",null,"Logs from the Terragraph driver can be found in syslog files\n(",(0,i.kt)("inlineCode",{parentName:"p"},"/var/log/kern.log"),") or via the ",(0,i.kt)("inlineCode",{parentName:"p"},"dmesg")," command. Logging verbosity is\ncontrolled by the node configuration field ",(0,i.kt)("inlineCode",{parentName:"p"},"envParams.FB_DRIVER_VERBOSE")," (see\n",(0,i.kt)("inlineCode",{parentName:"p"},"E_DBG_ENABLE_VALUE")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"fb_tgd_debug.h"),"). This bitmask can be viewed and set\ndynamically with the following commands, respectively:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ cat /sys/module/terragraph_{dhd,qca}/parameters/dbg_mask\n$ echo 0x10001 > /sys/module/terragraph_{dhd,qca}/parameters/dbg_mask\n")),(0,i.kt)("h3",{id:"poll-mode-driver-pmd-logs"},"Poll Mode Driver (PMD) Logs"),(0,i.kt)("p",null,"Logs from the PMD are contained within the DPDK application logs. For example,\nwhen using VPP, the PMD logs captured by VPP are extracted from syslog and\nwritten to ",(0,i.kt)("inlineCode",{parentName:"p"},"/var/log/vpp/vnet.log"),"."),(0,i.kt)("h3",{id:"firmwaremicrocode-logs"},"Firmware/Microcode Logs"),(0,i.kt)("p",null,"There are several methods for collecting firmware and microcode logs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"host_manager_11ad")," - This service runs automatically and writes logs to\n",(0,i.kt)("inlineCode",{parentName:"li"},"/var/log/wil6210/")," when the ",(0,i.kt)("inlineCode",{parentName:"li"},"envParams.FW_LOGGING_ENABLED")," node configuration\nfield is set. This is done through ",(0,i.kt)("inlineCode",{parentName:"li"},"start_host_manager_fw_log.sh"),", which uses\nthe ",(0,i.kt)("inlineCode",{parentName:"li"},"shell_11ad")," CLI to configure the ",(0,i.kt)("inlineCode",{parentName:"li"},"host_manager_11ad")," daemon. Logs are\nrotated and compressed, with retention set by the node configuration fields\n",(0,i.kt)("inlineCode",{parentName:"li"},"envParams.FW_LOGGING_FILE_COUNT")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"envParams.FW_LOGGING_FILESIZE_MB"),"."),(0,i.kt)("li",{parentName:"ul"},"PMD thread - When using VPP, a separate log polling thread can be enabled in\nthe PMD by passing the devargs ",(0,i.kt)("inlineCode",{parentName:"li"},"fw-log-path")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ucode-log-path")," for firmware\nand microcode logs, respectively."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wil_fw_trace")," - An alternative logging utility. To collect logs for ",(0,i.kt)("em",{parentName:"li"},"all"),"\nTalyn devices, use the script ",(0,i.kt)("inlineCode",{parentName:"li"},"run_wil_fw_trace.sh"),". Example usage:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ wil_fw_trace -d 0001:01:00.0 -s /data/firmware/wil6210/fw_image_trace_string_load.bin -v VERBOSE\n")),(0,i.kt)("p",null,"When no strings file is present, logs can be collected in opaque/binary form\ninstead, then decoded later using a matching strings file. To enable collection\nof opaque logs, either omit the strings parameter (",(0,i.kt)("inlineCode",{parentName:"p"},"-s"),") to ",(0,i.kt)("inlineCode",{parentName:"p"},"wil_fw_trace"),", or\npass the devarg ",(0,i.kt)("inlineCode",{parentName:"p"},"opaque-log=1")," (along with ",(0,i.kt)("inlineCode",{parentName:"p"},"fw-log-path"),") when using the PMD log\npolling thread. Decode the opaque logs using the ",(0,i.kt)("inlineCode",{parentName:"p"},"-O")," flag to ",(0,i.kt)("inlineCode",{parentName:"p"},"wil_fw_trace"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ wil_fw_trace -m /path/to/opaque_logs -s /data/firmware/wil6210/fw_image_trace_string_load.bin -O\n")),(0,i.kt)("p",null,"Separate settings control the verbosity of QTI firmware logs and Facebook\nfirmware logs (categorized as ",(0,i.kt)("inlineCode",{parentName:"p"},"FW_3P"),"):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'QTI firmware verbosity is set statically using the "DefaultVerbosity"\nparameter in ',(0,i.kt)("inlineCode",{parentName:"li"},"shell_11ad"),", or the ",(0,i.kt)("inlineCode",{parentName:"li"},"--verbosity")," flag in ",(0,i.kt)("inlineCode",{parentName:"li"},"wil_fw_trace"),". When\nusing ",(0,i.kt)("inlineCode",{parentName:"li"},"envParams.FW_LOGGING_ENABLED"),", the ",(0,i.kt)("inlineCode",{parentName:"li"},"host_manager_11ad")," service sets the\nverbosity according to the node configuration field\n",(0,i.kt)("inlineCode",{parentName:"li"},"envParams.FW_LOG_VERBOSE"),"."),(0,i.kt)("li",{parentName:"ul"},"Facebook firmware verbosity can be changed during runtime via the\n",(0,i.kt)("inlineCode",{parentName:"li"},"FW_SET_LOG_CONFIG")," command, e.g. using the CLI command\n",(0,i.kt)("inlineCode",{parentName:"li"},"tg2 minion fw_set_log_config"),".")),(0,i.kt)("h3",{id:"firmware-core-dumps"},"Firmware Core Dumps"),(0,i.kt)("p",null,"When using the PMD, core dumps are automatically written to\n",(0,i.kt)("inlineCode",{parentName:"p"},"/var/volatile/cores/wil6210_fw_core_<pci>_<date>")," after a firmware crash\noccurs. This path is configurable via the devarg ",(0,i.kt)("inlineCode",{parentName:"p"},"fw-core-dump-path"),"."),(0,i.kt)("p",null,"Firmware logs will automatically be read from the core dump, if possible, into\nthe file ",(0,i.kt)("inlineCode",{parentName:"p"},"<core-name>_trace.log"),". This uses the default strings file\n",(0,i.kt)("inlineCode",{parentName:"p"},"/data/firmware/wil6210/fw_image_trace_string_load.bin"),", which can be changed\nvia the devarg ",(0,i.kt)("inlineCode",{parentName:"p"},"fw-strings"),". Microcode logs cannot be read from the core dump.\nTo manually read firmware logs from a core dump, use the following\n",(0,i.kt)("inlineCode",{parentName:"p"},"wil_fw_trace")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ wil_fw_trace -m /path/to/core -s /data/firmware/wil6210/fw_image_trace_string_load.bin -o 0x1a01c0 -l 2\n")),(0,i.kt)("p",null,"When using the kernel driver, firmware core dumps must be manually generated by\nrunning the script ",(0,i.kt)("inlineCode",{parentName:"p"},"wil6210_core_dump.sh")," after a firmware crash is observed."),(0,i.kt)("h3",{id:"kernel-crashes"},"Kernel Crashes"),(0,i.kt)("p",null,"Terragraph handles kernel crashes (panics) by saving the kernel message log\n(dmesg) to log files and rebooting. The logs are saved under\n",(0,i.kt)("inlineCode",{parentName:"p"},"/data/kernel_crashes/vmcore.<date>")," (configured via\n",(0,i.kt)("inlineCode",{parentName:"p"},"meta-qoriq/recipes-kernel/kexec/files/kdump.conf"),")."),(0,i.kt)("p",null,"This works using kexec/kdump as follows. As part of a normal startup sequence,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/init.d/kdump")," script is executed. It registers a dump kernel (also\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"crashkernel"),", located at ",(0,i.kt)("inlineCode",{parentName:"p"},"/boot/Image-<version>-kdump"),") with the running\n(original/regular) kernel to be executed in case of a crash. When a crash\nhappens, the original kernel executes the registered crashkernel using kexec,\nwithout rebooting, which means that the memory contents of the original kernel\nremains available to the crashkernel. The crashkernel runs a regular userspace,\nincluding the ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/init.d/kdump")," script. The script notices that it's running\nas part of a crashkernel (by the presence of a ",(0,i.kt)("inlineCode",{parentName:"p"},"/proc/vmcore")," file), gets the\noriginal kernel messages (dmesg) from memory, saves them to\n",(0,i.kt)("inlineCode",{parentName:"p"},"/data/kernel_crashes")," and reboots. This time, it's a regular reboot that goes\nthrough the boot loader (rather than kexec), and loads the original kernel as\nusual."),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.dpdk.org/"},"DPDK")," - Data Plane Development Kit"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://wiki.fd.io/view/VPP"},"VPP")," - Vector Packet Processing"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://pktgen-dpdk.readthedocs.io/en/latest/"},"Pktgen")," - DPDK Packet Generator"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://doc.dpdk.org/guides/testpmd_app_ug/"},"Testpmd")," - DPDK Testpmd Application"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"},"hugepages")," - Linux hugetlbpage support"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.kernel.org/doc/Documentation/vfio.txt"},"VFIO")," - Virtual Function I/O"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.kernel.org/doc/html/latest/_sources/driver-api/uio-howto.rst.txt"},"UIO")," - Userspace I/O")))}m.isMDXComponent=!0}}]);