"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8359],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(n),k=r,u=c["".concat(s,".").concat(k)]||c[k]||m[k]||i;return n?a.createElement(u,l(l({ref:t},p),{},{components:n})):a.createElement(u,l({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5498:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={},l="Driver Interface",o={unversionedId:"developer/Driver_Interface",id:"developer/Driver_Interface",title:"Driver Interface",description:"This document describes the interface between user space applications and the",source:"@site/../docs/developer/Driver_Interface.md",sourceDirName:"developer",slug:"/developer/Driver_Interface",permalink:"/docs/developer/Driver_Interface",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Driver_Interface.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"Routing Layer",permalink:"/docs/developer/Routing_Layer"},next:{title:"Driver Stack",permalink:"/docs/developer/Driver_Stack"}},s={},d=[{value:"Architecture",id:"architecture",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Message Handling",id:"message-handling",level:3},{value:"Features",id:"features",level:3},{value:"Firmware Codebook Management",id:"firmware-codebook-management",level:5},{value:"GPS Management",id:"gps-management",level:5},{value:"PPS Timestamp Forwarding",id:"pps-timestamp-forwarding",level:5},{value:"PTP Hardware Clock Sync",id:"ptp-hardware-clock-sync",level:5},{value:"Performance Requirements",id:"performance-requirements",level:3},{value:"Message Formats",id:"message-formats",level:2},{value:"Netlink",id:"netlink",level:3},{value:"Thrift",id:"thrift",level:3},{value:"Command-Line Interfaces",id:"command-line-interfaces",level:2},{value:"&quot;r2d2&quot; CLI",id:"r2d2-cli",level:3},{value:"&quot;tg2&quot; CLI",id:"tg2-cli",level:3},{value:"Resources",id:"resources",level:2}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"driver-interface"},"Driver Interface"),(0,r.kt)("p",null,"This document describes the interface between user space applications and the\nTerragraph driver and firmware."),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"The E2E minion is responsible for communicating with the Terragraph driver and\nfirmware via its ",(0,r.kt)("inlineCode",{parentName:"p"},"DriverApp")," thread. ",(0,r.kt)("inlineCode",{parentName:"p"},"DriverApp")," uses a ZMQ pair socket\n(",(0,r.kt)("inlineCode",{parentName:"p"},"ZMQ_PAIR"),") to send and receive messages with the ",(0,r.kt)("em",{parentName:"p"},"driver interface"),"\n(",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if"),"). ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," then communicates with the Terragraph driver over a\nNetlink socket."),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/driver_if.svg",width:"320"})),(0,r.kt)("h3",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"Normally, ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," runs as another thread on the E2E minion process (spawned\nby the ",(0,r.kt)("inlineCode",{parentName:"p"},"Minion")," main class). ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," can run also in ",(0,r.kt)("em",{parentName:"p"},"daemon mode")," without\n",(0,r.kt)("inlineCode",{parentName:"p"},"DriverApp")," or other E2E minion modules by passing the ",(0,r.kt)("inlineCode",{parentName:"p"},"--driver_if_only")," flag."),(0,r.kt)("p",null,"A dedicated ",(0,r.kt)("inlineCode",{parentName:"p"},"ZmqMonitor")," instance is also spawned in a separate thread for\npushing driver and firmware stats (refer to\n",(0,r.kt)("a",{parentName:"p",href:"/docs/developer/Stats_Events_Logs"},"Stats, Events, Logs")," for further details)."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," is a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseDriverIf"),", and holds a corresponding Netlink\nsocket subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseNetlinkSocket"),". The subclasses are based on the\nmachine's architecture, listed in the table below. Note that the x86 classes\nare intended for emulation only and are largely incomplete."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Architecture"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"BaseDriverIf")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"BaseNetlinkSocket")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ARM"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ArmDriverIf")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ArmNetlinkSocket"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x86"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"X86DriverIf")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"X86NetlinkSocket"))))),(0,r.kt)("h3",{id:"message-handling"},"Message Handling"),(0,r.kt)("p",null,"Upon receiving a message from the ",(0,r.kt)("em",{parentName:"p"},"Netlink socket"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," does the\nfollowing:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Convert the Netlink message to a ",(0,r.kt)("inlineCode",{parentName:"li"},"DriverNlMessage")," instance using the\n",(0,r.kt)("inlineCode",{parentName:"li"},"ArmNetlinkSocket::recvFunc_()")," callback."),(0,r.kt)("li",{parentName:"ol"},"Convert the ",(0,r.kt)("inlineCode",{parentName:"li"},"DriverNlMessage")," to the corresponding ",(0,r.kt)("inlineCode",{parentName:"li"},"thrift::Message"),"\nstructure using ",(0,r.kt)("inlineCode",{parentName:"li"},"DriverIfUtil::driverNl2IfMessage()"),"."),(0,r.kt)("li",{parentName:"ol"},"Filter out and handle specific messages, including:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DR_RESP")," - log driver acknowledgements"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FW_STATS"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"DR_STAT_PUSH")," - publish stats from the firmware or driver to\n",(0,r.kt)("inlineCode",{parentName:"li"},"ZmqMonitor")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FW_HEALTHY")," - write firmware health status for the watchdog"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FW_PPS_HTSF_INFO")," - HTSF timing information"))),(0,r.kt)("li",{parentName:"ol"},"Forward remaining messages through the pair socket using\n",(0,r.kt)("inlineCode",{parentName:"li"},"BaseDriverIf::sendToDriverApp()"),".")),(0,r.kt)("p",null,"Upon receiving a message from the ",(0,r.kt)("em",{parentName:"p"},"pair socket"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," does the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Handle the ",(0,r.kt)("inlineCode",{parentName:"li"},"thrift::Message")," by invoking the corresponding function within\n",(0,r.kt)("inlineCode",{parentName:"li"},"BaseDriverIf::processMessage()"),"."),(0,r.kt)("li",{parentName:"ol"},"Convert the ",(0,r.kt)("inlineCode",{parentName:"li"},"thrift::Message")," structure to a ",(0,r.kt)("inlineCode",{parentName:"li"},"DriverNlMessage")," instance, then\nsend it to the driver as a Netlink message using\n",(0,r.kt)("inlineCode",{parentName:"li"},"ArmNetlinkSocket::sendMessage()"),".")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," publishes the following stats related to Netlink I/O:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tgd.nl.recv_ok")," - number of Netlink messages received successfully"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tgd.nl.recv_err")," - number of Netlink messages received unsuccessfully")),(0,r.kt)("h3",{id:"features"},"Features"),(0,r.kt)("p",null,"Some other notable features of ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," are described below."),(0,r.kt)("h5",{id:"firmware-codebook-management"},"Firmware Codebook Management"),(0,r.kt)("p",null,"The firmware downloads ",(0,r.kt)("em",{parentName:"p"},"codebooks")," (tables of antenna weights) from ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if"),"\nvia ",(0,r.kt)("inlineCode",{parentName:"p"},"FW_GET_CODEBOOK")," requests (",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::CodebookFetchReq"),"), which specify a\nchannel and range of beams. In order to respond with the correct codebook,\n",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," maintains state learned from the ",(0,r.kt)("inlineCode",{parentName:"p"},"NODE_INIT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"NODE_INIT_NOTIFY"),"\nmessage sequence for each radio, and captures relevant information (i.e. vendor,\ninitial beamforming procedure type, codebook variant) using the\n",(0,r.kt)("inlineCode",{parentName:"p"},"ArmDriverIf::RadioProperties")," struct. ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," will load codebooks on demand\nand cache them for the lifecycle of the process."),(0,r.kt)("h5",{id:"gps-management"},"GPS Management"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," contains an optional feature (enabled via the node configuration\nflag ",(0,r.kt)("inlineCode",{parentName:"p"},"envParams.GPSD_ENABLED"),") to connect to a local ",(0,r.kt)("a",{parentName:"p",href:"https://gpsd.gitlab.io/gpsd/"},"gpsd")," socket (on port\n2947). When enabled, ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseDriverIf")," creates a separate thread to read events\nfrom gpsd using the ",(0,r.kt)("inlineCode",{parentName:"p"},"GpsdClient")," class, which does the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Forwards all received timestamps to each firmware instance via ",(0,r.kt)("inlineCode",{parentName:"li"},"GPS_SEND_TIME"),"\nonce per second (only if ",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.PPS_TIMESTAMP_SOURCE"),' is set to "GPS"\nin the node configuration).'),(0,r.kt)("li",{parentName:"ul"},"Pushes GPS stats via ",(0,r.kt)("inlineCode",{parentName:"li"},"DR_STAT_PUSH"),"."),(0,r.kt)("li",{parentName:"ul"},"Forwards received location data to each firmware instance via\n",(0,r.kt)("inlineCode",{parentName:"li"},"GPS_SET_POS_REQ")," once only.")),(0,r.kt)("p",null,"For more details, see ",(0,r.kt)("a",{parentName:"p",href:"/docs/developer/Timing_Synchronization"},"Timing and Synchronization"),"."),(0,r.kt)("h5",{id:"pps-timestamp-forwarding"},"PPS Timestamp Forwarding"),(0,r.kt)("p",null,"More generally, ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," can forward 1PPS timestamps to Terragraph firmware\nfrom the following sources (",(0,r.kt)("inlineCode",{parentName:"p"},"timingParams.PPS_TIMESTAMP_SOURCE")," in the node\nconfiguration) to enable GPS/PPS sync mode:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GPS, via ",(0,r.kt)("inlineCode",{parentName:"li"},"GpsdClient")," (as described above)."),(0,r.kt)("li",{parentName:"ul"},"PTP hardware clock, via ",(0,r.kt)("inlineCode",{parentName:"li"},"PTPClockHelper"),". This utilizes a separate thread to\nread EXTTS events from a PTP device (",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.PTP_DEVICE"),") using the\n",(0,r.kt)("inlineCode",{parentName:"li"},"ioctl")," command ",(0,r.kt)("inlineCode",{parentName:"li"},"PTP_EXTTS_REQUEST"),"."),(0,r.kt)("li",{parentName:"ul"},"Software HTSF messages from Terragraph firmware, via ",(0,r.kt)("inlineCode",{parentName:"li"},"BaseDriverIf"),". On\nmulti-radio nodes with a common PPS signal to all baseband sectors, the\nsoftware HTSF PPS timestamps received from one RF sync sector are sent to the\nother sectors to enable PPS sync mode. When multiple sectors are publishing\nHTSF timestamps, ",(0,r.kt)("inlineCode",{parentName:"li"},"driver-if"),' picks the "source" sector based on the first\nmessage received, and will not switch to a different source sector until\n',(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.HTSF_MAX_LOOP_SIZE * 13")," seconds have elapsed in order to avoid\ntiming loops in the network; this delay is based on the number of missed\nseconds (PPS timestamps) before firmware will transition from PPS to RF sync\n(or bring down a link). Alternatively, the source sector can be hardcoded via\nthe node configuration field ",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.HTSF_SRC_MAC"),".")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," publishes the following stats to help monitor the state of timestamp\nforwarding:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tgd.gpsStat.MAC.numTsSent")," - number of GPS timestamps forwarded to ",(0,r.kt)("inlineCode",{parentName:"li"},"MAC"),"\n(only valid if ",(0,r.kt)("inlineCode",{parentName:"li"},"timingParams.PPS_TIMESTAMP_SOURCE"),' is set to "GPS")'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tgd.ptp.MAC.numTsSent")," - number of PTP hardware clock timestamps forwarded to\n",(0,r.kt)("inlineCode",{parentName:"li"},"MAC")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tgd.htsf.MAC.numTsSent")," - number of software HTSF timestamps forwarded to\n",(0,r.kt)("inlineCode",{parentName:"li"},"MAC"))),(0,r.kt)("h5",{id:"ptp-hardware-clock-sync"},"PTP Hardware Clock Sync"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," can be configured to synchronize a node's PTP (Precision Time\nProtocol) hardware clock based on 1PPS messages from a given timing reference\n(",(0,r.kt)("inlineCode",{parentName:"p"},"timingParams.PTP_TIMER_SOURCE")," in the node configuration) by correcting for\nphase offset and drift. The PTP clock is synchronized to GPS time (not UTC).\nPossible timing sources include a GPS device and software/hardware HTSF messages\nfrom Terragraph firmware."),(0,r.kt)("p",null,"Currently, the following clock types are supported:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"NXP DPAA2 (Data Path Acceleration Architecture Gen2) PTP clock, via direct\nregister access."),(0,r.kt)("li",{parentName:"ul"},'VSC 10G "Malibu" PHY LTC (local time counter) clock, via a custom datagram\nsocket protocol patched over the user-space "MESA" API. This can be enabled\nby setting the node configuration field ',(0,r.kt)("inlineCode",{parentName:"li"},"envParams.PTP_VSC_CTRL_SOCKET")," to any\nvalid path, which will be used for communication between ",(0,r.kt)("inlineCode",{parentName:"li"},"e2e_minion")," and\n",(0,r.kt)("inlineCode",{parentName:"li"},"malibu_char"),".")),(0,r.kt)("h3",{id:"performance-requirements"},"Performance Requirements"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," must be able to process messages in a timely manner, and major\nissues may emerge here if the host CPU is overloaded. Some common examples are\ndescribed below."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"PPS timestamp forwarding.")," On PPS sync nodes, ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," must reliably\nsend timestamps to Terragraph firmware once per second, and 10 missed seconds\nmay cause a link to go down."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Signs:")," ",(0,r.kt)("inlineCode",{parentName:"li"},"LINK_DOWN")," events with reason ",(0,r.kt)("inlineCode",{parentName:"li"},"SYSTEM_GPS_SYNC_IN_PROG"),";\nincrementing counter ",(0,r.kt)("inlineCode",{parentName:"li"},"tgf.MAC.gps.numMissedSec")," (despite stable GPS fix,\nif applicable)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Workarounds:")," Increase scheduling priority of gpsd (if applicable) or\n",(0,r.kt)("inlineCode",{parentName:"li"},"driver-if"),", e.g. using the ",(0,r.kt)("inlineCode",{parentName:"li"},"nice")," command"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Netlink communication.")," ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," must receive northbound messages from\nTerragraph firmware faster than they are produced to avoid dropping any\nNetlink messages."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Signs:")," Netlink errors reported by ",(0,r.kt)("inlineCode",{parentName:"li"},"driver-if")," and Terragraph driver (ex.\n",(0,r.kt)("inlineCode",{parentName:"li"},"ENOBUFS"),"), esp. as number of wireless links increases; incrementing\ncounter ",(0,r.kt)("inlineCode",{parentName:"li"},"tgd.nl.recv_err")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Workarounds:")," Reduce firmware stats frequency\n(",(0,r.kt)("inlineCode",{parentName:"li"},"radioParamsBase.fwParams.statsLogInterval"),"); omit some firmware stats\ncategories (",(0,r.kt)("inlineCode",{parentName:"li"},"radioParamsBase.fwStatsConfig.<category> = false"),")")))),(0,r.kt)("h2",{id:"message-formats"},"Message Formats"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," handles the translation between Thrift messages (user space) and\nNetlink messages (driver)."),(0,r.kt)("h3",{id:"netlink"},"Netlink"),(0,r.kt)("p",null,"Netlink types are enumerated in ",(0,r.kt)("inlineCode",{parentName:"p"},"tgd_nlsdn_commands"),", defined inside\n",(0,r.kt)("inlineCode",{parentName:"p"},"nl-driver-if/fb_tgd_nlsdn_common.h"),". These are manually mapped to\n",(0,r.kt)("inlineCode",{parentName:"p"},"DriverNlMessageType")," enum values inside ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if/DriverNlMessage.h"),"."),(0,r.kt)("h3",{id:"thrift"},"Thrift"),(0,r.kt)("p",null,"All Thrift messages to and from the driver use the same ",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::DriverMessage"),"\nbase structure defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"DriverMessage.thrift"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct DriverMessage {\n  1: binary value;\n  2: string radioMac;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"value")," contains the compact-serialized binary value of the actual Thrift\nstructure, and ",(0,r.kt)("inlineCode",{parentName:"p"},"radioMac")," is the origin or destination baseband MAC address\nrequired for multi-baseband boards."),(0,r.kt)("p",null,"Note that this structure must be wrapped inside of a ",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::Message"),"\nstructure, like with all other messages (refer to\n",(0,r.kt)("a",{parentName:"p",href:"/docs/developer/Communication_Protocol"},"Communication Protocol")," for further details). Thus,\nthe actual message type is double-serialized, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"mType")," field in the outer\nstructure describes the message type of the actual message (i.e. innermost\nstructure)."),(0,r.kt)("p",null,"Messages directly between ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," and firmware use the ",(0,r.kt)("em",{parentName:"p"},"pass-through"),"\n(",(0,r.kt)("inlineCode",{parentName:"p"},"PassThru"),") framework, with messages defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"PassThru.thrift"),". The base\nmessage type is ",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::PassThruMsg"),", with all possible messages embedded as\nnested structures and a separate message type field, ",(0,r.kt)("inlineCode",{parentName:"p"},"msgType"),", enumerated in\n",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::PtMsgTypes"),". When sending pass-through messages over Netlink, the\n",(0,r.kt)("inlineCode",{parentName:"p"},"DriverNlMessageType")," type for southbound messages (i.e. towards firmware) is\n",(0,r.kt)("inlineCode",{parentName:"p"},"PASSTHRU_SB")," and the type for northbound messages (i.e. towards ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if"),") is\n",(0,r.kt)("inlineCode",{parentName:"p"},"PASSTHRU_NB"),"."),(0,r.kt)("h2",{id:"command-line-interfaces"},"Command-Line Interfaces"),(0,r.kt)("p",null,"When run in daemon mode, interaction with ",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," is typically done via CLI\napplications, described below."),(0,r.kt)("h3",{id:"r2d2-cli"},'"r2d2" CLI'),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"r2d2")," is a Python-based command-line utility solely for communicating with\n",(0,r.kt)("inlineCode",{parentName:"p"},"driver-if")," and its ",(0,r.kt)("inlineCode",{parentName:"p"},"ZmqMonitor")," instance. This is mainly used for debugging and\nautomated testing purposes. For further implementation details, refer to\ndescriptions of the ",(0,r.kt)("inlineCode",{parentName:"p"},"tg")," CLI, which has a similar architecture (see\n",(0,r.kt)("a",{parentName:"p",href:"/docs/developer/Terragraph_CLI#terragraph-cli-tg-cli"},'"tg" CLI'),")."),(0,r.kt)("h3",{id:"tg2-cli"},'"tg2" CLI'),(0,r.kt)("p",null,"The majority of ",(0,r.kt)("inlineCode",{parentName:"p"},"r2d2")," functionality is also provided as part of the Lua-based\n",(0,r.kt)("inlineCode",{parentName:"p"},"tg2")," CLI. Commands and syntax are nearly identical, although there may be minor\ndifferences between argument/option names, program output, description text,\netc. A table mapping ",(0,r.kt)("inlineCode",{parentName:"p"},"r2d2")," commands to ",(0,r.kt)("inlineCode",{parentName:"p"},"tg2")," commands is given below:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"r2d2")," command"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"tg2")," command"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"r2d2 *")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tg2 fw *"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"r2d2 fw_stats")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tg2 stats driver-if"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"r2d2 fw_set_golay"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"r2d2 sync_bf_slot_exclusion_req"),(0,r.kt)("br",null),(0,r.kt)("inlineCode",{parentName:"td"},"r2d2 sync_scan")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"unsupported"))))),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://gpsd.gitlab.io/gpsd/"},"gpsd")," - GPS service daemon")))}m.isMDXComponent=!0}}]);