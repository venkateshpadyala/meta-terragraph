"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[98],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=s(n),u=r,h=c["".concat(p,".").concat(u)]||c[u]||f[u]||i;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3389:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={},l="Prefix Allocation",o={unversionedId:"developer/Prefix_Allocation",id:"developer/Prefix_Allocation",title:"Prefix Allocation",description:"This document describes Terragraph's algorithms for allocating prefixes to",source:"@site/../docs/developer/Prefix_Allocation.md",sourceDirName:"developer",slug:"/developer/Prefix_Allocation",permalink:"/docs/developer/Prefix_Allocation",draft:!1,editUrl:"https://github.com/terragraph/meta-terragraph/edit/main/docs/../docs/developer/Prefix_Allocation.md",tags:[],version:"current",frontMatter:{},sidebar:"developerManualSidebar",previous:{title:"Network Measurements",permalink:"/docs/developer/Network_Measurements"},next:{title:"Topology Discovery",permalink:"/docs/developer/Topology_Discovery"}},p={},s=[{value:"Background",id:"background",level:2},{value:"Centralized Prefix Allocation (CPA)",id:"centralized-prefix-allocation-cpa",level:2},{value:"Allocation",id:"allocation",level:3},{value:"Validation",id:"validation",level:3},{value:"Deterministic Prefix Allocation (DPA)",id:"deterministic-prefix-allocation-dpa",level:2},{value:"Segmentation Into Prefix Zones",id:"segmentation-into-prefix-zones",level:3},{value:"Allocate Prefix Spaces",id:"allocate-prefix-spaces",level:3},{value:"Prefix spaces to prefix lengths",id:"prefix-spaces-to-prefix-lengths",level:3},{value:"Zone prefixes from prefix lengths",id:"zone-prefixes-from-prefix-lengths",level:3},{value:"Node Prefixes",id:"node-prefixes",level:3},{value:"Miscellaneous",id:"miscellaneous",level:3},{value:"Validation",id:"validation-1",level:3},{value:"Changing Network Prefix",id:"changing-network-prefix",level:2},{value:"References",id:"references",level:2}],d={toc:s};function f(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"prefix-allocation"},"Prefix Allocation"),(0,r.kt)("p",null,"This document describes Terragraph's algorithms for allocating prefixes to\nnodes. Network prefix validation and allocation is handled by either\n",(0,r.kt)("inlineCode",{parentName:"p"},"CentralizedPrefixAllocator")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"DeterministicPrefixAllocator"),"."),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,'Terragraph networks are given an IPv6 "seed prefix" (e.g.\n',(0,r.kt)("inlineCode",{parentName:"p"},"face:b00c:cafe:ba00::/56"),") from which subnet prefixes are allocated to all DNs\nand CNs. There are three different methods for allocating node prefixes with\nOpen/R, described briefly below. For more details, refer to the Open/R\ndocumentation for ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/openr/blob/tg/openr/docs/PrefixAllocator.md"},"openr::PrefixAllocator"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Distributed")," - Distributed prefix allocation is completely handled within\nOpen/R. Under this scheme, nodes pick random prefixes from the allowed range\nand advertise them to the network. The algorithm attempts to resolve any\ncollisions, but is not always successful in practice; this can result in\nduplicated prefixes or unreachable nodes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Centralized (default)")," - Centralized prefix allocation is handled by the E2E\ncontroller. The controller performs all prefix allocations, which prevents\ncollisions and enables more sophisticated allocation algorithms."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Deterministic")," - Deterministic prefix allocation is also handled by the E2E\ncontroller. The controller assigns prefixes to nodes based on the network\ntopology to allow POP nodes to take advantage of route summarization and help\nload balance ingress traffic.")),(0,r.kt)("p",null,"Both centralized and deterministic prefix allocation require initial parameters\nto be provided through the ",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::PrefixAllocParams")," structure in the\ncontroller config file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct PrefixAllocParams {\n  1: string seedPrefix;\n  2: i32 allocPrefixLen;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"seedPrefix"),", the prefix of the entire Terragraph network, is given in ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc4632"},"CIDR"),"\nnotation. ",(0,r.kt)("inlineCode",{parentName:"p"},"allocPrefixLen")," specifies the bit-length of prefixes allocated to\neach node. If these parameters are not provided in the controller config, the\ncontroller will automatically revert to distributed prefix allocation."),(0,r.kt)("p",null,"Terragraph currently takes the ",(0,r.kt)("em",{parentName:"p"},"centralized")," approach."),(0,r.kt)("h2",{id:"centralized-prefix-allocation-cpa"},"Centralized Prefix Allocation (CPA)"),(0,r.kt)("h3",{id:"allocation"},"Allocation"),(0,r.kt)("p",null,"Given a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::PrefixAllocParams")," struct, the controller is able to\nallocate prefixes for all the nodes in the network automatically. However,\nindividual prefixes can also be manually defined through the ",(0,r.kt)("inlineCode",{parentName:"p"},"prefix")," field in\neach ",(0,r.kt)("inlineCode",{parentName:"p"},"thrift::Node")," entry."),(0,r.kt)("p",null,"The allocation steps are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"On controller startup:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the topology file specifies any node prefixes, mark them as taken."),(0,r.kt)("li",{parentName:"ul"},"For all nodes without prefixes, allocate one."))),(0,r.kt)("li",{parentName:"ul"},"When adding a node:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the prefix is unspecified, allocate one.")))),(0,r.kt)("p",null,"Allocation is performed by iterating sequentially through all possible prefixes\nand assigning the first unallocated prefix. For example, if allocating ",(0,r.kt)("inlineCode",{parentName:"p"},"/64"),"\nprefixes for nodes from the seed prefix ",(0,r.kt)("inlineCode",{parentName:"p"},"face:b00c:cafe:ba00::/56"),", the\ncontroller would assign prefixes in the following order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"face:b00c:cafe:ba00::/64\nface:b00c:cafe:ba01::/64\n...\nface:b00c:cafe:baff::/64\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"TopologyApp")," computes prefixes and periodically sends a ",(0,r.kt)("inlineCode",{parentName:"p"},"SET_PREFIXES")," command\nto any reachable POP node's ",(0,r.kt)("inlineCode",{parentName:"p"},"OpenrClientApp"),". If any prefixes changed, the\nminion injects the new prefixes into Open/R using the ",(0,r.kt)("inlineCode",{parentName:"p"},"KvStore")," key\n",(0,r.kt)("inlineCode",{parentName:"p"},"e2e-network-allocations"),"."),(0,r.kt)("h3",{id:"validation"},"Validation"),(0,r.kt)("p",null,"Checks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All prefixes (seed prefix and node prefixes) must be valid IPv6 prefixes in\nCIDR notation."),(0,r.kt)("li",{parentName:"ul"},"Node prefixes must be contained within the subnet of the seed prefix."),(0,r.kt)("li",{parentName:"ul"},"Node prefixes must be of the specified bit-length (",(0,r.kt)("inlineCode",{parentName:"li"},"allocPrefixLen"),").")),(0,r.kt)("p",null,"Constraints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Node prefixes must be unique within the network topology.")),(0,r.kt)("h2",{id:"deterministic-prefix-allocation-dpa"},"Deterministic Prefix Allocation (DPA)"),(0,r.kt)("p",null,"The CPA allocation is somewhat arbitrary. That is, no subnetting of the seed\nprefix occurs and each POP node is only able to advertise the entire seed prefix\nto BGP peers, rather than a more specific subnet. This makes it possible for\ningress traffic to enter the network through a suboptimal POP node."),(0,r.kt)("p",null,"Deterministic Prefix Allocation (DPA) assigns prefixes to nodes based on a given\ntopology to allow POP nodes to take advantage of route summarization and help\nload balance ingress traffic. DPA attempts to segment a TG network so that each\nPOP site can advertise its own specific BGP routes. Ingress traffic will then\nautomatically flow through the optimal POP, instead of tromboning between POPs."),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/dpa_prefix_zones.jpg",width:"650"})),(0,r.kt)("p",null,"Terminology:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Prefix zone")," - A group of nodes to their closest POP site (using wireless\nhop count as the distance metric)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Prefix space")," - The number of prefixes with length ",(0,r.kt)("inlineCode",{parentName:"li"},"allocPrefixLen"),"\nwithin a prefix. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"face:b00c:cafe:ba00::/56")," has a prefix space of\n256 (there are 256 unique /64s in a /56). Prefix spaces are always powers of 2\nand there is a direct translation from prefix length to prefix space:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"prefix_space = 2^(allocPrefixLen - prefix_length)\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Zone prefix")," - A prefix assigned to a prefix zone. Zone prefixes are used\nto allocate node prefixes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node prefix")," - A prefix with length ",(0,r.kt)("inlineCode",{parentName:"li"},"allocPrefixLen")," that can be assigned\nto a node.")),(0,r.kt)("h3",{id:"segmentation-into-prefix-zones"},"Segmentation Into Prefix Zones"),(0,r.kt)("p",null,"DPA begins by segmenting the network into prefix zones (one per POP site). This\nis accomplished by running a BFS algorithm starting from POP sites to find the\nclosest POP site, in terms of hop count, to each node. Nodes closest to a\nspecific POP site form a prefix zone."),(0,r.kt)("h3",{id:"allocate-prefix-spaces"},"Allocate Prefix Spaces"),(0,r.kt)("p",null,"Each prefix zone is allocated a number of prefixes so that the sum of their\nprefix spaces is at least as large as the number of nodes in the zone."),(0,r.kt)("p",null,"The recursive algorithm in pseudocode (Python) is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Python"},"def allocate_prefix_spaces(zones, network_prefix_space):\n    unsatisfied_zones = zones.get_unsatisfied_zones()\n    prefix_space_needed = 0\n    for zone in zones:\n        prefix_space_needed += zone.get_unsatisfied_node_count()\n\n    # Not enough network prefix space, so no solution.\n    if network_prefix_space < prefix_space_needed:\n         return False\n\n    # Used up all of the network_prefix_space, if no more prefix space is\n    # needed, then a valid solution was found, otherwise no solution.\n    if network_prefix_space == 0:\n        return prefix_space_needed == network_prefix_space\n\n    prefix_space_divisor = next_power_of_2(num_unsatisfied_zones)\n    while True:\n        remaining = network_prefix_space\n        prefix_space = remaining / prefix_space_divisor\n\n        # For each unsatisfied zone, add a prefix_space to it.\n        for zone in unsatisfied_zones:\n            zone.add_prefix_space(prefix_space)\n            remaining -= prefix_space\n\n        # Recurse with the remaining prefix space, if this results in a valid\n        # solution, return. Otherwise, double the divisor and repeat.\n        if allocate_prefix_spaces(zones, remaining):\n            return True\n\n        prefix_space_divisor *= 2\n")),(0,r.kt)("p",null,"The recursive algorithm is best explained with an example. Assume the following\nset up (based off of TowerG data):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"3 prefix zones",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Prefix zone A with 100 nodes"),(0,r.kt)("li",{parentName:"ul"},"Prefix zone B with  68 nodes"),(0,r.kt)("li",{parentName:"ul"},"Prefix zone C with  20 nodes"))),(0,r.kt)("li",{parentName:"ul"},"seedPrefix: ",(0,r.kt)("inlineCode",{parentName:"li"},"face:b00c:cafe:ba00::/56")),(0,r.kt)("li",{parentName:"ul"},"allocPrefixLen: 64"),(0,r.kt)("li",{parentName:"ul"},"Network prefix space: 256")),(0,r.kt)("p",null,"Since the seedPrefix is a ",(0,r.kt)("inlineCode",{parentName:"p"},"/56"),", the seedPrefix has a prefix space of 256.\nIn other words, this network can support up to 256 nodes, since each requires a\n",(0,r.kt)("inlineCode",{parentName:"p"},"/64"),"."),(0,r.kt)("p",null,"The algorithm first tries to equally divide the network prefix space to each\nprefix zone. Since prefix spaces are always powers of 2, divide the the network\nprefix space by 4 (since we have 3 prefix zones). This results in 4 prefix\nspaces of size 64 which are assigned to the three prefix zones and with a 64\nleft over."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone A (100)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone B (68)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone C (20)"),(0,r.kt)("th",{parentName:"tr",align:null},"Remaining"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64")))),(0,r.kt)("p",null,"Prefix zone C is satisfied since it has only 20 nodes. Since prefix zones A and\nC are not yet satisfied, recurse using the remaining prefix space of 64. Split\nthe the network prefix space (64) equally (divide by 2) and assign the prefix\nspaces (32) to each zone:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone A (100)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone B (68)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone C (20)"),(0,r.kt)("th",{parentName:"tr",align:null},"Remaining"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,"Now, prefix zone B is satisfied, but prefix zone A is not and there is no more\nremaining prefix space. The algorithm reaches a dead end, so it backtracks to\nthe previous state:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone A (100)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone B (68)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone C (20)"),(0,r.kt)("th",{parentName:"tr",align:null},"Remaining"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64")))),(0,r.kt)("p",null,"This time, instead of dividing by 2, the divisor is multiplied by 2 and we\ndivide the remaining (64) by 4. Then, assign a prefix space (16) to each of the\ntwo unsatisfied zones:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone A (100)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone B (68)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone C (20)"),(0,r.kt)("th",{parentName:"tr",align:null},"Remaining"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"32")))),(0,r.kt)("p",null,"Now, prefix zone A is the only unsatisfied zone and it can use the rest of the\nremaining prefix space."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone A (100)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone B (68)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone C (20)"),(0,r.kt)("th",{parentName:"tr",align:null},"Remaining"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,"All prefix zones are satisfied and the entire network prefix space has\nsuccessfully been divvied up."),(0,r.kt)("h3",{id:"prefix-spaces-to-prefix-lengths"},"Prefix spaces to prefix lengths"),(0,r.kt)("p",null,"Next, the prefix spaces need to be converted to prefix lengths."),(0,r.kt)("p",null,"The prefix space to prefix length conversion is trivial:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"prefix_length = allocPrefixLen - log_2 (prefix_space)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"log_2")," will work nicely since prefix spaces are restricted to powers of 2.\nThe prefix spaces from the previous example turn into:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone A (100)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone B (68)"),(0,r.kt)("th",{parentName:"tr",align:null},"Prefix zone C (20)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"/58"),(0,r.kt)("td",{parentName:"tr",align:null},"/58"),(0,r.kt)("td",{parentName:"tr",align:null},"/58")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"/60"),(0,r.kt)("td",{parentName:"tr",align:null},"/60"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"/59"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"\xa0")))),(0,r.kt)("h3",{id:"zone-prefixes-from-prefix-lengths"},"Zone prefixes from prefix lengths"),(0,r.kt)("p",null,"Converting a set of prefix lengths into actual prefixes involves traversing a\nbinary prefix tree from shortest to longest prefix."),(0,r.kt)("p",null,"The prefix tree looks like the following:"),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"/figures/dpa_prefix_tree.svg",width:"650"})),(0,r.kt)("p",null,"Create a mapping from prefix length to prefix zone:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"prefix_length_to_zone = {\n    58: [A, B, C],\n    59: [A],\n    60: [A, B]\n}\n")),(0,r.kt)("p",null,"For each prefix length (from shortest to longest) and for each prefix zone that\nrequires a prefix of said length, allocate a prefix from the prefix tree."),(0,r.kt)("p",null,"The tree allows tracking of previously allocated prefixes. Traverse the tree\nfrom the root, taking the left branch at each node. If an allocated prefix is\nencountered, backtrack and take the right branch. Note that this only works when\nprefix lengths are considered from shortest to longest."),(0,r.kt)("p",null,"The prefix tree concept can be replaced by a recursive function and a set\ncontaining previously allocated prefixes. See\n",(0,r.kt)("inlineCode",{parentName:"p"},"DeterministicPrefixAllocator::allocateZonePrefixesHelper()"),"."),(0,r.kt)("h3",{id:"node-prefixes"},"Node Prefixes"),(0,r.kt)("p",null,"After zone prefixes are allocated, node prefixes are allocated by iterating\nlinearly through all the zone prefixes for that node's zone. This is the same as\nthe currently used centralized prefix algorithm."),(0,r.kt)("h3",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("p",null,"During the prefix space allocation phase, multiple prefix spaces of the same\nsize may be allocated to the same prefix zone. These prefix spaces can be merged\ninto one larger space and is an implementation detail in\n",(0,r.kt)("inlineCode",{parentName:"p"},"PrefixZone::addToPrefixSpace()"),". This also makes the entire algorithm run\nsignificantly faster."),(0,r.kt)("p",null,"Currently, there is no convenient way to redistribute zone prefixes to allow for\nadditional nodes to be added. To mitigate this, there is\n",(0,r.kt)("inlineCode",{parentName:"p"},"PrefixZone::allocationSizeOverride_")," which overrides the initial zone size used\nfor prefix space allocation. This override is configured with the controller\nflag ",(0,r.kt)("inlineCode",{parentName:"p"},"dpa_zone_prefix_space_buffer"),". It defaults to 7, so 7 additional nodes\ncan be added to a prefix zone before it runs out of prefix space. Additionally,\nthere is an API endpoint ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/allocatePrefixes")," (or the ZMQ message type\n",(0,r.kt)("inlineCode",{parentName:"p"},"ALLOCATE_PREFIXES"),") that will redo the entire algorithm."),(0,r.kt)("h3",{id:"validation-1"},"Validation"),(0,r.kt)("p",null,"Checks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All prefixes (seed prefix, zone prefixes and node prefixes) must be valid IPv6\nprefixes in CIDR notation."),(0,r.kt)("li",{parentName:"ul"},"Node prefixes must be contained within a subnet of one of their zone's\nprefixes."),(0,r.kt)("li",{parentName:"ul"},"Node prefixes must be of the specified bit-length (",(0,r.kt)("inlineCode",{parentName:"li"},"allocPrefixLen"),")."),(0,r.kt)("li",{parentName:"ul"},"Zone prefixes must be in the subnet of the seed prefix.")),(0,r.kt)("p",null,"Constraints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Node prefixes must be unique within the network topology."),(0,r.kt)("li",{parentName:"ul"},"Zone prefixes have enough prefix space to allocate node prefixes for all of\nthe prefix zone's nodes.")),(0,r.kt)("h2",{id:"changing-network-prefix"},"Changing Network Prefix"),(0,r.kt)("p",null,"When using either centralized or deterministic prefix allocation, changing the\nnetwork prefix becomes a multi-step process since the controller can lose\nreachability to the network when there is a mismatch between the allocated node\nprefixes and the network prefix advertised in BGP."),(0,r.kt)("p",null,"This can be solved by advertising both the old and new network prefixes in BGP\nduring the transition. This can be done manually using the\n",(0,r.kt)("inlineCode",{parentName:"p"},"bgpParams.specificNetworkPrefixes")," node config field on any POP node."),(0,r.kt)("p",null,"Additionally, the controller tries to automate some of these steps. The\nfollowing are the recommended steps to change the network prefix when either\ncentralized or deterministic prefix allocation is enabled:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Change the ",(0,r.kt)("inlineCode",{parentName:"li"},"seedPrefix")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"controller_config.json")," to the new prefix."),(0,r.kt)("li",{parentName:"ol"},"Wait until the static node prefixes are updated in KvStore by running\n",(0,r.kt)("inlineCode",{parentName:"li"},"breeze kvstore alloc-list")," on a node in the network. Alternatively, the new\nprefix will be reflected in the nodes' IP addresses in NMS."),(0,r.kt)("li",{parentName:"ol"},"Change the ",(0,r.kt)("inlineCode",{parentName:"li"},"e2e-network-prefix")," to the new prefix in ",(0,r.kt)("inlineCode",{parentName:"li"},"kvstoreParams")," on the\nPOP nodes.")),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/openr/blob/tg/openr/docs/PrefixAllocator.md"},"openr::PrefixAllocator")," - Open/R's prefix allocation scheme"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/rfc4632"},"CIDR")," - Classless Inter-domain Routing (RFC 4632)")))}f.isMDXComponent=!0}}]);